# Hacker News 故事摘要 - 2025-10-02

## 今日概述

Today’s top Hacker News stories are about complex blogging tools, choosing simple programming languages, and CPU design. The first story looks at using Emacs Org mode and Babel for blogging, which is powerful but hard to understand. The second story is about building a blog with Lua to keep things simple and stable. The third story discusses why RISC-V CPUs do not have a conditional move instruction and how this affects design. If you like tools, programming languages, or computer hardware, today’s stories have something for you.

---

## Babel is why I keep blogging with Emacs

- 原文链接: [Babel is why I keep blogging with Emacs](https://entropicthoughts.com/why-stick-to-emacs-blog)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=45453222)

This article talks about why the writer keeps using Emacs with Org mode and Babel for blogging, even though it is complex. They feel jealous when they see simple static site generators, and wish their own setup was easier to understand and control.

The writer uses Org mode to write blog posts, and then uses Emacs’ Org publishing tools to export them to HTML. But this process uses lots of Emacs Lisp code—over 20,000 lines, if you count all the parts needed. This makes the setup hard to understand and explain to others. The writer does not really know what happens behind the scenes when they publish a file, and feels it is too complicated to follow all the code.

They think about making a simple, custom blogging tool, maybe 2,000 lines of code, which would be easier to understand and change. But they do not do this, because of one key feature: Babel. Babel lets them write code blocks in their blog posts and run the code when exporting. The output, like tables or images, gets included in the final blog post. They can even use results from one code block in another, and mix code with variables from the text. For the writer, this is very useful, especially for things like making plots with R and refining both the data and the text together. They say once you try this, it is hard to go back.

So, even though the current setup is hard to understand and sometimes breaks, Babel’s power keeps them from switching to something simpler. They wish it was less complex, but the features are worth it for their workflow.

In the comments, some people agree that Org mode and Babel are powerful, but also say they are too complex and hard for new users. Others say they use simpler tools, like Markdown, because they do not need to run code in their posts. Some people like having everything in Emacs, while others think it is better to use separate tools that do only one job. A few users mention that the learning curve for Emacs and Org mode is steep, but once you learn it, you do not want to go back. Some people share tips for making Org publishing easier or more stable. There are comments about how writing your own static site generator can be fun, but keeping it working over time is hard. Others point out that tools like Jupyter Notebooks offer similar features, but in a different way. A few say that if Babel is the “killer feature” for the writer, then it makes sense to stick with Emacs, even if it is complicated. Overall, the comments show both respect for Org mode’s power and concern about its complexity.

---

## Why I chose Lua for this blog

- 原文链接: [Why I chose Lua for this blog](https://andregarzia.com/2025/03/why-i-choose-lua-for-this-blog.html)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=45452261)

This article is about why the author rebuilt their blog using Lua instead of other, more common languages like JavaScript or Ruby. They wanted a blog system that would stay simple and work for many years without breaking.

The author first explains their old setup used Racket with lots of custom code, but it became too hard to maintain. They wanted something that did not need constant updates or changes. JavaScript, their main language, seemed like the easy choice, but it moves too fast—old code often breaks and needs fixing. The author says that the Node.js and NPM world changes too quickly, so keeping a blog working for years is a lot of work. Other languages have the same problem, but not as much.

Lua is different because it changes very slowly. Lua 5.1 came out in 2006, and Lua 5.4 in 2020, but even then, the changes are small. Lua is also easy to set up—only needing a simple C compiler—and the author finds it simple to use. Their blog now works with old-school CGI scripts, a SQLite database, and HTML templates. They don’t care about handling lots of visitors; even 50,000 in a week is fine with their system.

The author likes that Lua has fewer libraries, but enough to get the job done. They write many small tools themselves, keeping the codebase simple and easy to understand. With Lua, they don’t have to worry about big changes breaking their blog. They can remember how everything works and feel sure that it will keep working for many years. Lua feels like a set of building blocks, letting them make what they want without extra stuff.

In the comments, some people agree with the author. They say using a small, stable language is smart if you want your project to last. They also talk about their own trouble with JavaScript or Ruby projects breaking after only a few years. A few readers mention how fun it is to use Lua, and how easy it is to learn and use for small projects. Some people think the author’s approach is too simple, or worry that Lua’s small library selection can be a problem for bigger needs.

Others point out that modern tech stacks can be fast and easy to use, but only if you keep up with updates. One commenter says the author is brave for writing everything from scratch, but also that it’s fun and teaches you a lot. Some wonder if using CGI is too old-fashioned, but the author and others reply that for a personal blog, it’s fine. A few readers suggest other simple languages, like Go or Python, but agree that Lua is a good choice if you know it well. Many comments say it’s nice to see someone choose what works for them, not just what’s popular. Finally, some people thank the author for sharing their story and say they might try Lua, too.

---

## RISC-V Conditional Moves

- 原文链接: [RISC-V Conditional Moves](https://www.corsix.org/content/riscv-conditional-moves)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=45413059)

This article talks about how the RISC-V CPU instruction set does not have a simple “conditional move” instruction like the one found in aarch64 processors. The author explains why this matters for programmers and CPU designers.

On aarch64, there is an instruction called `csel` that lets you pick between two values based on a condition, all in one step. It is flexible and can do things like convert a condition to a boolean, make a mask, or compute the absolute value of a number. You can do many small tricks using just this instruction.

RISC-V, which is a popular new instruction set, does not have a direct version of `csel`. You can sometimes use other instructions like `slt`, or use extra instruction set extensions like Zbb’s `min`/`max` or Zicond’s `czero.eqz` and `czero.nez`. But these only cover special cases, not the general need for conditional moves. The RISC-V manual says they left out conditional moves on purpose. Instead, they suggest using short branches for this kind of logic.

Some RISC-V CPU cores try to fix this by automatically turning simple branch instructions into something like a conditional move in the hardware (this is called “macro fusion”). But this is not always safe. The RISC-V memory model says that a branch makes a “control dependency” for all store instructions after it. If you turn a branch into a conditional move, you lose this dependency, which can change how memory operations happen. This could break some programs, because the order that the CPU writes to memory may change in ways that are not allowed.

So, the main point is: even if a conditional move and a branch look the same at first, they are not always the same because of these memory ordering rules. CPU designers need to be careful if they try to merge branches into conditional moves.

In the comments, some people said they like the simplicity of RISC-V’s design, even if it means some things are less efficient. Others wish RISC-V would add more flexible instructions like aarch64’s `csel`, since it can help compilers make faster code. A few explained that the memory model problem is very important, especially for multi-core systems. Some readers pointed out that it is easy to make mistakes if you don’t fully understand the memory model. Others shared that real-world performance may not change much, since modern CPUs are already very good at handling branches. One person noted that adding more instructions can make CPUs more complex and harder to verify. Another commenter said that RISC-V’s focus on simplicity helps with open hardware projects. There was also discussion about how different compilers work around these missing instructions. Some readers argued that hardware fusion might be worth it if it makes code smaller and faster, while others warned it could lead to hard-to-find bugs. In the end, people agreed that trade-offs between simplicity, performance, and correctness are hard to balance.

---

