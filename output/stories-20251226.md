# Hacker News 故事摘要 - 2025-12-26

## 今日概述

Today’s top Hacker News stories look at new tools for Python and 3D images, open-source license issues, and new science findings like a mushroom that causes rare hallucinations. There are also big discussions about how Kubernetes works, using Git as a database, and a new security bug in MongoDB. Many stories focus on making tech faster or safer, while others show new ways to learn or build software. If you like news about programming, open source, or science, today has something interesting for you.

---

## How uv got so fast

- 原文链接: [How uv got so fast](https://nesbitt.io/2025/12/26/how-uv-got-so-fast.html)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=46393992)

The article explains why uv, a new Python package manager, is much faster than pip. Many people think it’s just because uv is written in Rust, but the real reason is a mix of new standards and smart design choices.

For a long time, Python’s packaging system was slow because it had to run each package’s setup.py script to find out what dependencies were needed. This was risky and slow, since it could run any code. Over the years, new standards (PEP 518, 517, 621, and 658) allowed package info to be read from simple files like pyproject.toml, without running code. This change made it possible for uv to be fast, since it could just read the needed info directly.

uv is fast not only because of Rust, but also because it skips many old, slow features. For example, uv does not support the old .egg format or pip.conf config files. It doesn’t compile Python bytecode by default, which saves time. It always requires virtual environments, so it doesn’t need to check system permissions. It’s also stricter about package rules and ignores unnecessary version limits, which means less backtracking and faster installs. When searching for packages, uv stops at the first match, saving more time.

Some of uv’s speed boosts could be added to pip, even though pip is written in Python. For example, uv uses HTTP range requests to grab only part of a package file, downloads packages in parallel, and keeps a global cache with hardlinks to save space. It has a better dependency resolver algorithm (PubGrub) and doesn’t need to start up Python for every task.

A few things do need Rust for extra speed, like “zero-copy” reading of cached data, lock-free concurrency, and not needing to start an interpreter for subprocesses. But these are smaller gains compared to the big wins from dropping old features and using new standards.

The article concludes that uv is fast because it can skip old, slow paths and use new packaging standards. Rust helps, but it’s not the main reason. Pip can’t drop old features because it needs to stay compatible with old packages, so it will always be slower.

In the comments, some readers agree that dropping legacy support is key to uv’s speed, not just Rust. Others point out that pip’s focus on compatibility is important for big companies and older codebases. A few mention that other ecosystems like Rust’s Cargo and JavaScript’s npm have used static metadata for years, and Python is just catching up.

Some users worry uv’s strictness and lack of legacy support could make it hard for some projects to switch. Others are happy to see Python package management finally get faster and easier. There is debate about whether pip should try to copy uv’s tricks or if the two tools should focus on different users. A few people share technical details about the PubGrub algorithm and zero-copy deserialization, saying these are good choices but not the main speed boost.

Some commenters hope pip will adopt parallel downloading and better caching, but others doubt it will happen soon due to old code and the need for backward compatibility. A handful of readers think Rust is still important for safety and speed, even if it’s not the only factor. Overall, the mood is positive about uv, with many saying it’s a big improvement for Python development.

---

## How Lewis Carroll computed determinants

- 原文链接: [How Lewis Carroll computed determinants](https://www.johndcook.com/blog/2023/07/10/lewis-carroll-determinants/)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=46395106)

This article explains how Lewis Carroll, who wrote “Alice in Wonderland,” invented a new way to find the determinant of a matrix, called Dodgson condensation. The method is useful not just for humans doing math by hand, but also for computers.

Dodgson’s idea is to make the matrix smaller step by step. You take each group of four numbers (a 2×2 square) and find its determinant, which is a simple calculation. You do this for every spot in the matrix except for the last row and last column, which you remove. You keep repeating this process, making the matrix smaller each time, until you’re left with a single number—the determinant.

After the first step, you have to divide each new number by a value from the original matrix. The article notes that Dodgson’s old math paper is easy to read, even though the notation is different from today’s style. One confusing part in the paper is about which number to use in the division, because the example Dodgson gave doesn’t help clear this up.

There’s an example using a 4×4 matrix, and the method finds the same answer as a computer algebra system (Mathematica): 228. Dodgson’s method involves division, so you must avoid dividing by zero. He suggests moving rows or columns to make sure there are no zeros inside the matrix before you start.

If the matrix only has whole numbers, the method always gives exact answers with whole numbers at every step. The article compares Dodgson’s method to other ways to find determinants. The cofactor expansion is slow for big matrices. Gaussian elimination is much faster, but sometimes gives fractions even if the input is all whole numbers. Dodgson’s condensation is fast (like Gaussian elimination), keeps whole numbers, and each small step can be done at the same time, which is good for computers.

In the comments, some people praise Dodgson’s method as clever and simple, but others point out its limits. Some say it’s hard to use if there are zeros inside the matrix, because of the risk of dividing by zero. A few mention that for very big matrices or in real-world software, Gaussian elimination is still more common and trusted.

Others like that Dodgson’s method is easy to teach to students and helpful for those learning about matrices. One commenter says it’s neat that the method mostly works with whole numbers, but warns that it doesn’t always work with matrices that have special structures. Someone else notes that this method is parallelizable, which means computers can do many calculations at once.

There’s also talk about how Lewis Carroll was not just a writer, but a smart mathematician who liked puzzles. A few people share links to other resources and math papers about determinants. Some wish textbooks would include Dodgson’s method more often, since it’s both historic and practical for small problems.

---

## Experts explore new mushroom which causes fairytale-like hallucinations

- 原文链接: [Experts explore new mushroom which causes fairytale-like hallucinations](https://nhmu.utah.edu/articles/experts-explore-new-mushroom-which-causes-fairytale-hallucinations)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=46393936)

This article talks about a newly discovered mushroom called Lanmaoa asiatica that causes people to see tiny, fairytale-like people after eating it. Scientists found this mushroom in Yunnan, China, where it is sold in big street markets and known as Jian shou qing, meaning “turns blue in the hand” because it changes color when touched.

The mushroom is not related to common “magic mushrooms” and its special effects are not fully understood yet. People who eat this mushroom, especially if it is undercooked, often see “little people” running around their table or even in their soup—a rare type of hallucination called Lilliputian Hallucinations. These stories have been told in China, Papua New Guinea, and even the Philippines, showing that this is not just local folklore.

In China, almost everyone seems to know about Jian shou qing’s strange effects. Some people even measure the tiny people they see and share funny stories about them. Scientists tried to find out what chemical in the mushroom causes this effect, but so far, they have not found any known hallucinogen. DNA tests also showed that online packs of dried Jian shou qing mushrooms often contain the wrong, sometimes poisonous, mushrooms.

Researchers found that the same species of mushroom is eaten in the Philippines, where it also causes people to see little people called “ansisit.” This means the effect is real and not just made up by one group. Chemical studies on the mushroom in the lab showed that mice act very differently after eating extracts from it, so scientists are still trying to find the exact compound that causes the visions.

The article says that this mushroom is more closely related to porcini mushrooms than to magic mushrooms. Old Chinese texts talk about mushrooms that let you “see a little person,” which suggests people have known about this effect for a long time.

In the Hacker News comments, some readers are amazed by the story and want to know more about the science behind the hallucinations. A few say they wish there was more information about the safety of eating these mushrooms, since mixing up wild mushrooms can be dangerous. Others are curious if the compound in Lanmaoa asiatica could be used for medical research or new treatments, especially since it is different from other hallucinogens.

Some commenters point out the cultural side: they find it interesting that so many places around the world have stories about seeing “little people” after eating mushrooms. One person wonders if this helped create old fairy tales. There are also comments warning not to try wild mushrooms without expert help, because some are very poisonous and look similar to safe ones. A few readers joke about what it would be like to see tiny people in their soup, while others are excited for more research and hope the mystery compound can be found soon.

---

## How I think about Kubernetes

- 原文链接: [How I think about Kubernetes](https://garnaudov.com/writings/how-i-think-about-kubernetes/)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=46396043)

This article is about how to think about Kubernetes, a tool often used for managing containers in the cloud. The writer says Kubernetes is not just an orchestrator, but more like a system where you declare what you want your infrastructure to look like, and Kubernetes keeps working to make that happen.

He explains that Kubernetes uses a “type system,” similar to programming languages. For example, you define things like Pods, Deployments, and Services in YAML files. Each type has rules about what it can do and how it can change. Pods are single units, but usually, you use higher-level types like ReplicaSet or Deployment to manage many pods, or Service to give them a stable network. You can even make your own types with CRDs (Custom Resource Definitions).

When you run `kubectl apply -f pod.yaml`, Kubernetes doesn’t just run the script once. It saves your declaration and works to keep your cluster matching what you want. If the system changes or a pod fails, Kubernetes tries to fix it to match your original request. This is called “reconciliation.”

Deleting a pod by hand doesn’t always work, because if the desired state says the pod should exist, Kubernetes will bring it back. The “spec” in a resource is what you want, and the “status” is what is really happening. You can debug problems by comparing these.

The writer also talks about GitOps, where the true desired state is stored in Git, not just the cluster. A GitOps controller checks if the cluster matches what’s in Git, and if not, it fixes it. So, if you change something with kubectl but it’s managed by GitOps, your change will probably get reverted by the controller. His advice is to use kubectl for debugging, not for making changes, if GitOps is used.

He says thinking of Kubernetes as a runtime for declarative infrastructure helps in practice: you should change the desired state, not just fix issues by hand; let reconciliation happen; make clear who owns what with tools like GitOps; and use the right resource types.

In the comments, some people agree that thinking in terms of “desired state” and reconciliation makes Kubernetes easier to understand and use. Others say the system is still very complex, especially for small teams or simple projects. Some users share that Kubernetes can feel too heavy for small apps, and that for simple needs, other tools might be better.

A few readers highlight that the “type system” idea is useful, especially when working with custom resources or large teams. Others mention that GitOps brings its own problems, like confusion when trying to debug what changed and why, or fights between what’s in Git and what’s in the cluster.

Some commenters point out that even with a declarative system, there can be a gap between what you want and what actually happens, so debugging skills are still important. Others like the comparison to programming languages, saying it helps them explain Kubernetes to new team members.

There are also voices that warn about “over-abstracting,” making things more complicated than needed. Some people wish Kubernetes were simpler, or that more guides would explain things in these simple terms. A few users mention that while the model is powerful, it takes time to learn and get used to, and beginners often get lost with all the types and controllers.

A few remind readers that not everything needs Kubernetes and to pick tools based on real needs. Others add that once you get used to the “declarative” and “runtime” ideas, you can better avoid manual mistakes and let the system do the hard work.

---

## Gaussian Splatting 3 Ways

- 原文链接: [Gaussian Splatting 3 Ways](https://github.com/NullandKale/NullSplats)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=46395273)

This project is a desktop app that lets you train and view 3D Gaussian splats using your own videos or photos. It works on Windows, uses Python, and relies on GPU power with CUDA and PyTorch. 

The app guides you through four main steps: first, you load a video or some images; next, it finds good frames and uses COLMAP to get camera positions; then, it trains 3D splats using one of three methods (gsplat, Depth Anything 3, or SHARP); finally, you can view and export your results. It wraps tools like COLMAP for structure-from-motion, uses OpenGL to show the splats, and keeps all files in a cache so you can repeat or continue work later. The three supported splat methods have different needs and results: gsplat is for multi-view, Depth Anything 3 uses depth prediction, and SHARP works even from a single image. The app has a simple user interface with tabs for each step and supports live previews during training. It saves all scene data in a structured folder so you can manage many projects. There are example files and videos showing the output quality for each method.

People in the comments are interested in how easy the tool is to set up, with some noting that Windows and CUDA are required, which may limit use. Some users are impressed by the quality of results from just one or a few views, especially with SHARP. Others talk about the heavy memory use, especially with Depth Anything 3, and wonder if future updates could make it more efficient or support more platforms like Linux. There are questions about how the app compares to other 3D capture methods and if it can be used for VR or game development. Some praise the clear structure of the code and the use of caching, which helps with reproducibility. Others wish for easier package management or a web version. A few share ideas for making camera controls better or adding more export options. Overall, the project is seen as exciting and useful, but some hope for improvements in ease of use and platform support.

---

## Package managers keep using Git as a database, it never works out

- 原文链接: [Package managers keep using Git as a database, it never works out](https://nesbitt.io/2025/12/24/package-managers-keep-using-git-as-a-database.html)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=46391514)

This article talks about how package managers often use Git like a database, but this idea always causes problems as the projects get bigger. At first, using Git is easy because it handles version history and is free to use, but it does not scale well for package management.

The article gives many examples. Cargo, the Rust package manager, started by using a Git repo for its package index. When the index was small, it worked fine. But as the number of packages grew, cloning or updating the index became very slow, especially in CI systems. Cargo fixed this by moving to a system where it only downloads the files it needs over HTTP.

Homebrew had similar troubles. Users had to download hundreds of megabytes just to get updates, and GitHub asked the project to stop using shallow clones because it was very expensive for their servers. Homebrew switched to using JSON files over HTTP, speeding up updates for everyone.

CocoaPods, used for iOS and macOS, also grew too large for Git. Cloning the specs repo became slow, and GitHub set limits because the load was too high. The team switched to using a CDN to serve files directly, making installs much faster.

Nixpkgs uses tarballs and CDNs to avoid these problems for users, but the main Git repo is still huge and causes trouble for GitHub’s systems. The repo has grown to over 80GB because of all the forks and CI jobs.

vcpkg, Microsoft’s C++ package manager, also uses Git for versioning. It needs the full history to look up exact versions, so shallow clones do not work, leading to errors and difficult workarounds. Unlike others, vcpkg has not moved away from Git.

Go modules had slow installs because the tool would clone full repos to read one file. The Go team built a proxy to serve files over HTTP, making installs much faster and safer by avoiding direct use of Git.

The article also shows problems in other tools, like wikis and content management systems that use Git as storage. These tools face slowdowns, API limits, and other scaling issues.

The main issue is that Git is built for code collaboration, not as a database. It struggles with things like too many files in one folder, case sensitivity problems, path length limits, and missing database features like checks and indexes. Each time, teams try to fix the problems, but the best solution is to use real databases or HTTP services in the end.

In the Hacker News comments, many people agree with the article and share their own stories of trouble with Git as a database. Some say that using Git seems smart at first because it is already there and easy, but it always leads to pain later. Others point out that it works fine for small projects, but breaks down when things grow.

Some commenters defend using Git, saying that it is good for tracking changes and code review. They note that for read-heavy, write-light use cases or with small datasets, Git can still work well. A few mention that switching to HTTP or a database adds new problems, like needing to run extra services.

Others discuss technical issues, like how Git is slow with big directories, and how problems with case sensitivity and file path limits waste developer time. Some wish that package managers would learn from each other and not repeat the same mistakes.

A few people say that the flexibility of Git is still useful, and that for private or small-scale use, it might be the best option. Some also mention that having everything in Git makes it easy to audit and backup, which is harder with separate databases.

Finally, many agree with the article’s advice: if you are building something that looks like a database, use a real database or simple HTTP service, not Git. They say it is better to face the work early than to suffer slow speeds and scaling problems later.

---

## My insulin pump controller uses the Linux kernel. It also violates the GPL

- 原文链接: [My insulin pump controller uses the Linux kernel. It also violates the GPL](https://old.reddit.com/r/linux/comments/1puojsr/the_device_that_controls_my_insulin_pump_uses_the/)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=46395184)

This story is about an insulin pump, a device that helps people with diabetes, which uses the Linux kernel as its main software. The person who owns the pump found out that the company making it does not follow the GPL license rules for Linux.

The Linux kernel is free and open software. Its license, called the GPL, says that if you use or change Linux in a product, you must share your changes and the source code when asked. The person tried to get the source code from the company, but they did not provide it. This is a problem because the GPL is there to make sure people can check, fix, or improve the software they depend on. The article explains that this is not just about rules—it is about trust, safety, and user rights, especially for medical devices that people’s lives depend on.

The author gives examples of why sharing code is good. If there is a bug, anyone can look, report, or fix it. If the company stops supporting the product, users and other developers can still keep it working or make it safer. The author also talks about how hard it is to get companies to follow the GPL. Many just ignore it, and there is not much a user can do except complain or go to court.

In the comment section, people share different views. Some agree that it is wrong for companies to break the GPL, especially with life-saving devices. Others point out that many companies ignore open-source licenses, and enforcement is weak. A few say that open source is risky for medical devices because bad code might get into products that must be very safe.

One person says users should be able to fix their own devices, just like fixing a car. Someone else asks if the company at least provides security updates, since that is very important for medical gear. Another commenter wonders if open code would really help, since most users cannot change it anyway.

Some suggest that only big companies or groups can really enforce the GPL, because regular people do not have the money for lawyers. Others worry that companies might just stop using Linux and switch to closed systems, which could be worse for users. A few mention projects where open source really improved safety and trust.

In the end, the comments show that people care about both user rights and product safety. They also show that the rules about open-source software are often ignored, and fixing this is still a big challenge.

---

## MongoBleed

- 原文链接: [MongoBleed](https://github.com/joe-desimone/mongobleed/blob/main/mongobleed.py)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=46394620)

This post is about a new security exploit called “MongoBleed” that targets MongoDB servers. The exploit takes advantage of a memory leak bug, tracked as CVE-2025-14847, where attackers can trick MongoDB into leaking pieces of its memory.

The main idea is that the attacker sends a specially crafted request to the MongoDB server. The request uses zlib compression and lies about the size of some data. Because of a bug in how MongoDB decompresses and reads certain fields, the server ends up reading too much and sends back data from its memory that was not supposed to be shared. This leaked data can include sensitive information, like field names or even secrets such as passwords, tokens, and keys. The exploit script (mongobleed.py) automates this attack. It sends many crafted requests with different document lengths to try to leak as much memory as possible. The script then saves all the leaked data into a file and highlights anything that looks like a secret. The author explains in the code comments that the vulnerability is triggered by the way MongoDB handles BSON (its data format) and compressed messages, especially when the reported length does not match the real length.

In the comment section, many people are concerned that this is a serious bug, especially since it can leak private data without needing to log in. Some users compare it to the famous Heartbleed bug, which also leaked memory from servers. Others warn that many MongoDB servers are exposed to the internet without good security, making this bug even more dangerous. Some commenters say that this kind of bug shows why input validation and memory safety are so important in server software. A few people discuss how to protect against this exploit, such as keeping servers updated, using strong firewalls, and not exposing databases directly to the internet. There are also users who note that this attack needs the server to accept compressed messages, and not every server does. Some wonder how quickly MongoDB will release a fix, while others suggest that users should act fast to patch or protect their systems. Lastly, a few people thank the author for sharing the exploit details, as it helps defenders understand and stop the attack.

---

## LearnixOS

- 原文链接: [LearnixOS](https://www.learnix-os.com)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=46391599)

LearnixOS is a project and book where you learn how to build your own operating system using Rust, without any external libraries. The book explains each step, from simple code to full features, and shares all the code and ideas in detail.

The author wants readers to really understand OS development, so everything is explained clearly. You don’t need to be a Rust expert, but you should know at least one programming language, basic assembly (like simple moves and numbers), and what memory and pointers are. If you ever feel lost, you are encouraged to ask questions or raise issues, so the book can be improved.

The roadmap shows what you will build: first, you compile a simple program, then work on boot loading, CPU modes, and memory management like paging and your own malloc. Next, you build things like interrupt handling, file systems, disk drivers, and processes. Later, you write a shell and finally run your first program (Doom!). The author even hopes to add virtualization and running other OSes in the future.

The book uses custom syntax highlighting for Rust code, and readers can help report bugs or problems. The focus is on learning by doing, and every step is explained, including why each choice is made. The author is also learning Rust, so both beginners and more advanced programmers can follow along.

In the comments, many people like the idea of learning OS development in Rust. Some are excited to see a project that does not use big libraries and explains everything from the ground up. A few think this will help more people try systems programming, since Rust is safer than C and easier to learn for new developers. Others hope the book will stay simple and not assume too much knowledge too early.

Some commenters ask if the book will cover real hardware, or just run in emulators. Others wonder if being POSIX-compliant is too hard for a first OS project, but like the ambitious goal. A few share other OS projects for learning, comparing LearnixOS to them. There are questions about how deep the book will go into hardware and whether it will discuss things like device drivers or networking.

Overall, the community seems supportive and happy to see a beginner-friendly, clear, and open project for learning OS concepts in Rust. Some offer advice or tips, while others are just excited to follow along.

---

## FFmpeg has issued a DMCA takedown on GitHub

- 原文链接: [FFmpeg has issued a DMCA takedown on GitHub](https://twitter.com/FFmpeg/status/2004599109559496984)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=46394327)

FFmpeg developers say that a company called IloveRockchip copied thousands of lines of FFmpeg code without following the license rules. For almost two years, FFmpeg waited for IloveRockchip to fix this problem, but nothing happened, so one developer filed a DMCA takedown on GitHub. The copied code was found in Rockchip’s video driver, and the license was changed from LGPL to something else, which is not allowed. LGPL means you can use the code, but you must also share your changes and give credit. FFmpeg shared proof of the copied code on social media and explained why this is a big problem.

Many people on Hacker News support FFmpeg’s action. They say licenses are important, and companies should respect open-source rules. Some commenters think IloveRockchip should have fixed the problem earlier, since they had two years to do it. Others worry that DMCA takedowns are too strong and can hurt projects that use open source by mistake. A few people say it’s common for companies to break open-source licenses, but it’s still wrong. Some users want GitHub to help with these problems, maybe by warning projects if they use code with the wrong license. There are also people who think open-source projects should make it easier for companies to follow the rules. In the end, most agree that copying code without following the license is not fair, and it is good that FFmpeg stood up for their work.

---

