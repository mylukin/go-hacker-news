# Hacker News 故事摘要 - 2025-09-21

## 今日概述

Today’s top Hacker News stories talk about new high-speed trains in America, tiny tools for coding in C and Zig, and testing calculators. Other stories cover Google’s forensic tool, debugging games on Windows ARM64, early cave symbols, how hard app marketing can be, a beginner book on encrypted math, and a power bank shaped like a gummy bear. If you like travel, coding, history, security, or gadgets, there is something interesting to read today.

---

## Rail travel is booming in America

- 原文链接: [Rail travel is booming in America](https://www.economist.com/united-states/2025/09/21/rail-travel-is-booming-in-america)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=45326230)

Rail travel in America is growing fast, with more people choosing to take the train. The article talks about how Amtrak, the main train company in the US, is getting attention with new trains and even popular social media videos. Amtrak’s latest train, the new Acela, started running between Boston and Washington, DC. This new train is faster and more modern, and the company is proud to show it off, even using Beethoven’s music in videos to make it feel special.

The article says train travel is becoming more like Europe, where trains are common and popular. Amtrak is trying to make riding the train more fun and comfortable to win over more riders. The company is also using social media, like TikTok, to reach new and younger people. More trains are running, and more people are buying tickets. New train lines and new carriages are coming, so the service is getting better.

Travelers like trains because they can relax, use WiFi, and do not need to drive or go through airport security. Trains are also better for the environment than cars or planes. Cities and states are helping by paying for new train projects. High-speed rail is a big goal, but it is expensive and slow to build in the US. Still, the number of passengers is going up, and people hope the trend will continue.

In the Hacker News comments, some people are excited and hopeful about the future of trains in America. They say trains are a good way to travel, and they want more lines and faster service. Others think the US still has a long way to go. They point out that trains are slower than in Europe or Asia and that ticket prices can be high. Some say that government rules and too much paperwork make it hard to build new tracks.

A few commenters share good stories about riding trains, but others had bad experiences with delays or old trains. Some people say they would use trains more if the stations were easier to reach or if the trains were cheaper. Others worry that train travel will not work well in small towns or far-away places. There is also talk about how hard it is to get people to stop driving cars in America. In the end, many agree that more and better trains would be nice, but they do not all believe it will happen soon.

---

## Sj.h: A tiny little JSON parsing library in ~150 lines of C99

- 原文链接: [Sj.h: A tiny little JSON parsing library in ~150 lines of C99](https://github.com/rxi/sj.h)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=45324349)

This project is a very small JSON parsing library for C called sj.h, with only about 150 lines of code. It is written in C99 and aims to be simple and easy to use for reading JSON in C programs. The library does not use dynamic memory allocation, so it is fast and has a small memory footprint. You can get helpful error messages with line and column numbers if something goes wrong. However, sj.h does not handle numbers or strings itself—you must use your own code to parse numbers (like with `strtod` or `atoi`), and you must handle Unicode or special string cases on your own.

The example in the README shows how to load a rectangle from a JSON string into a C struct. You create a reader, read the JSON object, and then iterate over its keys and values, matching each key and assigning the value to the right field in the struct. This makes sj.h good for simple tasks where you just want to get data out of JSON and you control the format. The code is public domain, so you can use it for any project without worry.

In the comments, some people love the small size and simplicity, especially for embedded systems or quick projects. They say it is easier to understand and debug than big libraries. Others point out that sj.h leaves out many things, like number and string parsing, so it is only good for simple uses or as a starting point. Some warn that handling JSON fully is hard—Unicode and edge cases are not easy, and sj.h puts that work on the user. There are comments comparing sj.h to other small libraries, with some preferring ones that handle more cases out of the box. A few people like that error messages include line and column numbers, making debugging easier. Some suggest it is a nice tool for learning how JSON parsing works. Others think it is not a good fit for “real” projects because of missing features. There are also people who just like seeing code that is short and clear. Overall, people respect the effort and see its value, but agree it is best for simple or controlled situations, not for general-purpose JSON parsing.

---

## Calculator Forensics (2002)

- 原文链接: [Calculator Forensics (2002)](https://www.rskey.org/~mwsebastian/miscprj/results.htm)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=45293438)

This article is about "calculator forensics," a method for testing how different calculators handle math functions. It checks how well calculators calculate a special formula: arcsin(arccos(arctan(tan(cos(sin(9)))))), using degrees mode.

The article lists many calculator models and the result they give for this formula. The "forensics" result should be close to 9, but many calculators give answers that are a little different. Some old calculators show big errors, like 0 or over 70. Most modern calculators show results very close to 9, but still with tiny differences, like 8.99999999 or 9.00000001. The article also names the chips and display types used in each calculator and notes special cases, like calculators that use different math methods or display formats.

Some calculators use Binary-Coded Decimal (BCD) math, while others use floating point. The method helps people tell which calculators use which math method, and to spot bugs or design choices in calculator software and hardware. The article even mentions calculators that do not properly switch to degree mode for all steps, or that give different answers depending on settings like "EXP" or "FLOAT." 

From the comments, some users remember using this test in school or at work to check calculators. Others point out that this formula is not just a fun trick—it helps people see how small math errors can show up after many function calls. Some say the results can be used to identify the calculator chip used, even if the brand is unknown. A few people explain why some calculators fail badly: early models had less memory and weaker chips, so they cut corners. One user warns not to trust calculators too much for serious science or engineering, because even small errors can matter. Another comment says most people using calculators for basic math do not care, but for programmers or scientists, these differences can be important. Some find it cool how nerds use simple tricks like this to learn about hardware, while others think it is a bit silly, since most people only care if 2+2=4. Overall, many enjoy seeing a big list showing the "secret life" of calculators.

---

## Timesketch: Collaborative forensic timeline analysis

- 原文链接: [Timesketch: Collaborative forensic timeline analysis](https://github.com/google/timesketch)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=45324343)

Timesketch is an open-source tool made by Google for teams to work together on forensic timeline analysis. It lets users upload and organize events from digital investigations, add notes and tags, and see everything on a timeline. Timesketch is web-based, so many people can look at and work with the same data at once. You can upload different types of logs and digital evidence. The tool has features like comments, rich labels, and the ability to “star” important events. There are new AI tools built-in, like automatic log analysis and report writing with large language models (LLMs). Analysts can now use a “question and answer” workflow—asking questions, collecting evidence, and writing up findings right inside the tool. The system also keeps track of links between events and conclusions, making it easier to see how evidence supports an investigation. Timesketch supports plugins and can be deployed with Docker for easy setup. It is written mostly in Python and Vue.js, and has a strong community with many contributors.

In the Hacker News comments, some users say Timesketch is very useful for digital forensics and incident response (DFIR). People like that it is open source and that it allows for team work. Some mention using it in real cases, finding it helpful for sorting through big logs quickly. Others note that setup can be a bit complex, especially for beginners, and that Docker helps but still needs some technical skills. A few users wish there were more guides or videos to help new users learn the workflow. There is discussion about the new AI features—some think they are a big help, while others are unsure if AI is ready for serious investigations yet. One user points out that linking evidence to conclusions inside the tool is a smart idea. A few compare Timesketch to commercial products and say it is strong for something free. Some hope it will get more plugins and integrations in the future. Others mention using Timesketch with other tools like Plaso for building timelines. Overall, the community seems positive, with some advice to improve the user experience for new people.

---

## DXGI debugging: Microsoft put me on a list

- 原文链接: [DXGI debugging: Microsoft put me on a list](https://slugcat.systems/post/25-09-21-dxgi-debugging-microsoft-put-me-on-a-list/)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=45323207)

This article is about a game developer trying to debug why Space Station 14 crashes on Windows ARM64 when using ANGLE (a graphics library). The developer wanted the game launcher to support both ARM64 and x64, but testing on ARM64 caused the game to crash with no clear error logs.

The first step was checking logs, but they were empty after SDL (the window library) started. The developer used WinDbg, a Windows debugger, and found the crash happened in a Windows function called GetDC, but the code looked broken and wrong for ARM64. Debugging C# code did not work because of problems with .NET debug tools and mismatched CPU architectures. After some trial and error, the developer found WinDbg was confused because the launcher was x64, but the real game was ARM64, so the debugger got stuck between emulated and native modes.

Switching to launching the ARM64 executable directly fixed some problems. The developer then swapped in a custom SDL build to get better debug info. They saw the crash happened when SDL tried to clear the window using GetDC, which should not happen on ARM64 but did not crash on x64. Looking at the disassembly, the code was missing some expected ARM instructions and had weird jumps.

It turned out Microsoft’s DXGI library (used for DirectX graphics) was adding a “detour”—a kind of code patch—into GetDC for some games. Microsoft does this to force old games to use a faster “flip model” for displaying graphics in Windows 11. This patch, though, broke things on ARM64 for this game. The developer found that if they disabled this Windows optimization, the crash stopped.

The real surprise came when the crash only happened if the file was named SS14.Loader.exe. Microsoft keeps a list of game executables and applies this optimization (and the risky detour) only to those names. Because the developer’s game is on that list, it triggers the code that crashes on ARM64, even though almost no other ARM64 games use that filename.

In the comments, some people were surprised Microsoft would use such hacks in their own APIs, calling it risky or “gross.” Others pointed out that Microsoft has a long history of using “app-compat shims” and hard-coded lists for compatibility, which often leads to weird bugs like this. A few developers shared similar stories about problems caused by Windows optimizing for older games or handling special cases. Some commenters were sympathetic, saying debugging on Windows ARM64 is still very new and rough, so bugs like this will be common for a while. Others joked about being “on a list” and wondered how many secret lists like this exist inside Windows. Some said the best fix is to stop using OpenGL or ANGLE and move to more modern graphics APIs, but agreed that’s a lot of work. There was also discussion about how hard it is to get good OpenGL support on ARM64 Windows, and that Microsoft’s driver choices make things harder for indie developers. One or two people suggested just renaming the .exe as a workaround, but others noted that’s not always possible due to Steam or distribution issues. Overall, many readers agreed the debugging story was wild and a good example of how complicated Windows compatibility can be, especially as new hardware and platforms appear.

---

## 40k-Year-Old Symbols in Caves Worldwide May Be the Earliest Written Language

- 原文链接: [40k-Year-Old Symbols in Caves Worldwide May Be the Earliest Written Language](https://www.openculture.com/2025/09/40000-year-old-symbols-found-in-caves-worldwide-may-be-the-earliest-written-language.html)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=45286622)

This article says that people may have started using a type of written language much earlier than we thought—maybe 40,000 years ago, not just 5,000 years ago with the Sumerians. A scientist named Genevieve von Petzinger studied old cave symbols found all over Europe and found that the same 32 basic signs kept showing up in different places and times, like dots, lines, triangles, and hand stencils. She thinks these simple marks could have been an early system for sharing ideas, kind of like how we use emoji today. Some of these signs are even found on things like jewelry, not just cave walls. Other scientists argue about what these signs mean. Some say the symbols were just decorations or were always next to animal drawings, so they might not really be a language. But others, including a linguist from MIT, believe that making these marks shows abstract thinking like language. There is also the idea that these signs might have helped people remember stories or important events, and they could be the first step toward writing.

People in the comments have many opinions. Some say that just because symbols look the same, it does not mean they meant the same thing everywhere. Others think early humans were smarter than we give them credit for, and making symbols was a big step. A few believe these signs could show that people once had one shared language before it split up, connecting it to stories like the Tower of Babel. Some point out that symbols often have different meanings in different cultures, and that is normal even today. One person says the symbols might just mean “I was here,” like graffiti. Another says that symbols could be connected to things like hunting or finding water—real needs of people long ago. Some commenters bring up DNA and genetics, wondering if the spread of these signs matches how people moved around. There are even jokes about some symbols looking like modern things (like soccer fields or video game icons). In the end, most agree that it’s hard to know for sure what these marks meant, but it is fun and important to ask questions about our past.

---

## I forced myself to spend a week in Instagram instead of Xcode

- 原文链接: [I forced myself to spend a week in Instagram instead of Xcode](https://www.pixelpusher.club/p/i-forced-myself-to-spend-a-week-in)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=45322819)

The writer is an app developer who decided to stop coding for a week and focus only on marketing their fitness app, Lagree Buddy, using Instagram. Instead of building new features in Xcode, they spent business hours creating content, reaching out to trainers, and talking to users online.

They noticed that after adding a paywall and improving onboarding, more people paid for the app. But many big features were not ready yet, so the writer wondered: what if they put all their effort into marketing instead of coding? This idea was very uncomfortable, as they preferred building features over self-promotion. To make Instagram posts feel less like ads, they tried telling stories—breaking a day’s events into several posts that showed problems, fixes, and wins. They also messaged trainers and studios, getting a few replies.

The process was harder than expected. Making creative, good-looking content took much longer than planned. Sometimes, they reused Instagram stories for TikTok, and used online tools to make fun Q&A posts. They also joined real fitness classes to get fresh photos and meet influencers, like the founder of the Lagree workout method. These connections felt more valuable than building new features, even if the app’s analytics did not improve much that week.

They learned that “build it and they will come” is false—you have to tell people about your app. Cold messages rarely get many answers, but even a small response rate is better than nothing. Marketing and making relationships opens doors that coding alone cannot. Content creation is much more work than it seems, especially for developers used to building, not promoting.

In the Hacker News comments, many developers related to the author’s discomfort with marketing. Some said they also hide in code and avoid talking to users, even though they know it’s important. Several readers agreed that marketing and outreach are often more important than making more features, and that “build it and they will come” is a trap for many indie hackers. Others pointed out that content creation is a real skill, and that it’s easy to underestimate the time and effort it takes.

A few commenters shared their own stories about getting out of their comfort zone, like cold-calling or posting on social media, and found it awkward but necessary. Some questioned whether Instagram is the best place to find users for every app, suggesting that picking the right channel matters. Others warned that over-promoting can annoy people or feel spammy, and that real relationships and honest stories work better than hard sells.

Many liked the author’s idea of using stories and real-life events instead of only polished ads. Some disagreed with the idea of stopping all coding, saying balance is better, but most agreed that marketing deserves more developer attention. The top comments encouraged developers to try marketing tasks themselves, even if it feels strange, because it’s how users find out about new things.

---

## Show HN: I wrote an OS in 1000 lines of Zig

- 原文链接: [Show HN: I wrote an OS in 1000 lines of Zig](https://github.com/botirk38/OS-1000-lines-zig)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=45290590)

Someone wrote an operating system using only 1,000 lines of Zig code and shared it on GitHub. The project is called OS-1000-lines-zig and aims to be a simple, fast, and easy-to-understand OS for learning or testing ideas.

The OS uses a monolithic kernel, meaning the core system and user programs run together as one program. It supports basic things like running small programs, managing memory, and offering a simple command-line interface. You need the Zig compiler (version 0.10.0 or higher) to build and run it. After cloning the repository, you can build with a simple command and then run the OS to see a basic shell. You can use it to print “Hello World,” view memory use, or list running processes. The main parts live in a small number of files: the kernel, common helpers, and a build script. If you want to change settings, you can edit a config file and rebuild. The project includes some simple tests to check if it works. There are plans to add more features like better process control, a bigger shell, networking, and filesystems in the future. Anyone can contribute by making a pull request. The code is under the MIT license, so you can use or change it freely.

In the comments, some people are excited to see an OS written in so little code and think it’s great for learning. Several users mention that Zig is a good fit for this kind of project, since it is simple and fast, but also safer than C. A few users compare this to other “tiny OS” projects in C or Rust, and wonder how the features compare. Some commenters want to know if it can run on real hardware or just in an emulator. Others point out that real-world operating systems are much bigger and have more safety checks, but agree that small projects like this are nice for showing the basics. A few people ask for a blog post or more comments in the code to help them learn from it. One user warns that working with operating systems is hard, and you need to be careful about bugs and memory errors, even in Zig. Another person says it’s good to see more projects in Zig, because the language is growing. Some wish it had more documentation or examples, while others say the code is easy to follow if you know basic OS ideas. A few mention that writing even a small OS is a great way to learn about how computers work at a low level.

---

## The Beginner's Textbook for Homomorphic Encryption

- 原文链接: [The Beginner's Textbook for Homomorphic Encryption](https://arxiv.org/abs/2503.05136)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=45323027)

This article is about a beginner’s textbook for Fully Homomorphic Encryption (FHE), a type of cryptography that lets computers work on data while it is still encrypted. FHE means you can run programs and get answers, even though you never see the real data until the end.

The book explains that FHE allows you to do math like addition and multiplication on encrypted numbers. With these two actions, you can build other functions—like subtraction, division, and even logic gates (AND, OR, and so on). You can also make more complex things, like the ReLU or sigmoid functions used in machine learning, or trigonometric functions like sin and cos. Sometimes these are exact, sometimes only close estimates, because the more correct the answer, the slower things can get.

A big use for FHE is privacy-preserving machine learning, where a server can run a model on your encrypted data, but never learns what your data is or what the answer is. Only you, with your key, can unlock the result. FHE can also help make confidential blockchains, where smart contracts use private data but still stay open and trustworthy. Other ideas include safe database queries, private searches, and letting many people sign something together without sharing their secrets.

The book is open for others to help improve. The goal is to make FHE easier to learn, since it is often seen as hard and confusing. The author hopes experts will add more examples and make things clearer for new learners.

In the comments, many people say FHE is very interesting but still too slow for most real-world jobs. Some users are excited to see a beginner-level book, since most FHE writing is too hard to understand. Others share they tried FHE for simple tasks, but even then it took a long time to finish. A few mention that big companies are working to make it faster, but it might take years before it is easy to use everywhere.

Some readers ask if FHE is safe against quantum computers, and others reply that, so far, the math behind FHE is believed to be strong. There are also questions about which FHE libraries or tools are best for learning, and people give tips and share links to open-source projects. A few say they worry about the trade-off between privacy and speed, and suggest FHE will be most useful in special cases, not for everyday use yet.

Overall, the comments show hope for the future of FHE, but also point out there are still many problems to solve. People like that this textbook is open and easy to join, and they hope it will help more people learn and use FHE in the future.

---

## Why your outdoorsy friend suddenly has a gummy bear power bank

- 原文链接: [Why your outdoorsy friend suddenly has a gummy bear power bank](https://www.theverge.com/tech/781387/backpacking-ultralight-haribo-power-bank)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=45322135)

This article talks about a new kind of power bank that looks like a big gummy bear. These power banks are popular with people who love hiking and camping. The gummy bear power bank is made by a company called Nitecore, and it is called the Nitecore NB10000 Gummy.

The main reason people like this power bank is because it is very light and small. It weighs only about as much as a candy bar but can charge a phone more than once. The shape is soft and rounded, so it fits easily in a backpack or pocket. The case is made out of a special rubbery plastic that feels nice and protects it from bumps and drops. The bright colors make it easy to find in a bag or if you drop it outside.

The power bank is also water resistant, which is good for outdoor use. It charges quickly and works with most phones and small devices. People like that it uses USB-C, which is the same cable many devices use today. There are also safety features to stop it from overheating or overcharging.

The article explains that hikers and campers care a lot about the weight of their gear, so every gram matters. The gummy bear power bank is one of the lightest choices, which is why it is getting popular. Its fun look also makes it a good gift or conversation starter.

In the comment section, some people are excited about the design and how light it is. Others point out that the shape is a bit silly but agree it is practical. A few users mention that they used to carry heavier power banks and wish this lighter one was available before. Some are worried about the power bank looking like candy—especially for kids who might try to eat it by mistake.

Other commenters talk about how important it is to have a reliable power source in the outdoors, and they like that this one is water-resistant. A few people think the price is too high for a small battery, while others say good gear is worth paying for. Some share tips about charging devices more efficiently when hiking. A couple of people mention other brands they like, but most agree that lighter is usually better for hiking.

---

