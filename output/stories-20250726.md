# Hacker News 故事摘要 - 2025-07-26

## 今日概述

Today’s top Hacker News stories cover new tech and science ideas. There is news about the AMD Zen 5 CPU, a safer way to make structs in Zig, a free OCaml textbook, and a security bug in Microsoft Copilot. Other stories look at the Purple Earth theory, old Hawaiian petroglyphs, a tool to run Rust code on any GPU, and a language for writing CPU rules. There’s also news from Taiwan politics and tips for better Bash scripts.

---

## Test Results for AMD Zen 5

- 原文链接: [Test Results for AMD Zen 5](https://www.agner.org/forum/viewtopic.php?t=287&start=10)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44696167)

The article shares test results for the new AMD Zen 5 CPU, focusing on how it improves computer performance. The author explains that Zen 5 brings big changes, especially by doubling the instruction fetch rate from 16 to 32 bytes per clock—something that was a big problem in older CPUs.

Zen 5 can now handle up to six instructions at once, and sometimes even eight, but this depends on how the software is written. If instructions depend on each other, the CPU can't work as fast, so programmers need to write code carefully. The number of parts inside the CPU that actually do work (execution units) is higher, with six for simple math, four for addressing, three for decisions (branches), and more for handling vectors (large sets of numbers). This means the chip waits less for parts to be free, making it faster.

For vector work, like in scientific or graphics programs, Zen 5 can do two additions, two multiplications, and two reads or writes every clock, all with wide 512-bit units for most actions. Memory reads and writes are also faster—up to four reads per clock for simple numbers, or two reads and two writes at once.

Decisions in programs (branches) are much quicker. Zen 5 can quickly handle two taken or three not-taken branches each clock, and it can look ahead at branches and even decode both paths at once. This makes running complex code with lots of 'if' statements faster.

Some operations are a bit slower now, like integer vector addition, which takes two clock cycles instead of one, but floating point addition is now faster. Both types now match in speed.

Cache (the fast memory inside the chip) is not much bigger or better than before, so sometimes the main limit is moving data in and out of memory, not the CPU's own speed. The biggest gains will be seen in programs that do lots of calculations and don't have to wait much for memory or disk.

In the Hacker News comments, many people are impressed by the technical details and the improvements in instruction fetching, saying this fixes an old weakness. Some comment that while the CPU is much faster, it will only help programs that are CPU-limited, not those that wait on memory. Others note that most real-world software is still limited by memory speed, so the full power of Zen 5 might not always show up. A few programmers talk about the need to change how they write code to really take advantage of the new design. Some are excited for how this might help data science, AI, and games, while others want to see real-world benchmarks, not just technical tests. There's also curiosity about how Zen 5 compares to new Intel chips, and some wonder if software tools will keep up to use all the new features. Overall, the community is impressed but cautious, waiting to see how these changes help in everyday work.

---

## Resizable Structs in Zig

- 原文链接: [Resizable Structs in Zig](https://tristanpemble.com/resizable-structs-in-zig/)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44697131)

This article talks about making structs in Zig that can change size at runtime. Today, Zig makes it hard to have structs where some fields have sizes you only know while the program is running.

The writer explains that Zig has arrays, pointers, and slices for storing data, but all fields in a struct must have fixed sizes when you write your code. Sometimes, you want a struct where some fields get bigger or smaller as the program runs, like buffers or lists inside a struct. Right now, to do that, you must do a lot of manual work: calculate the size you need, allocate enough memory, split that memory into different parts for each field, and keep track of all the sizes. This is hard and easy to get wrong, causing bugs or even security problems.

Other languages have "variable length arrays," but Zig does not want to add them. The author suggests a new way: a kind of struct where some fields are marked as resizable arrays. This is done using Zig's "comptime" features, which let you write code that runs when your program is being built, not when it runs.

The solution uses a helper struct called `ResizableArray(T)`. Then you wrap your fields in another struct called `ResizableStruct`, which knows which fields are resizable. You can then easily get pointers to each field and resize them as needed. All the data stays together in memory, making it fast and simple to use. The author shares a working example on GitHub, with easy methods like `init`, `get`, `resize`, and `deinit`.

Now, looking at the top Hacker News comments, people mostly like the idea. Some say this fixes a real pain point in Zig, making certain patterns much easier. Others point out that you still have to be careful with memory alignment and not making mistakes when resizing. A few users compare this to similar ideas in C, such as "struct hack" or flexible array members, but note that Zig's solution is safer and less error-prone.

One commenter says this could help with things like network buffers or file formats. Another is worried about how well this works with Zig's safety goals, especially if someone misuses the API. Some people wonder if this should be in the standard library, or if it's better as a third-party package for now. There are also questions about performance and if the "comptime" tricks make programs slower or harder to debug.

In summary, the main feeling is that this fills a gap in Zig and helps make complex data structures easier to build. Many want to see more real-world examples and maybe better error checking in the API. Some are excited to try it out, while others just want to watch and wait to see how it works in practice.

---

## OCaml Programming: Correct and Efficient and Beautiful

- 原文链接: [OCaml Programming: Correct and Efficient and Beautiful](https://cs3110.github.io/textbook/cover.html)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44696979)

This article is about a free textbook called "OCaml Programming: Correct + Efficient + Beautiful," used for teaching functional programming and data structures at Cornell University. The book focuses on using OCaml to write programs that are correct (no bugs), efficient (fast), and beautiful (easy to read and understand).

The book guides students through OCaml basics, like how to install it, write simple programs, and use the OCaml toplevel for testing code. It explains how to work with data and types, such as lists, records, trees, and exceptions. There are chapters about writing higher-order functions (like map and filter), and how to use modules to organize code. The book also covers correctness, including how to write good documentation, use testing tools, and even prove code works as expected. It teaches about mutability (changing data), data structures (like hash tables and red-black trees), and how to analyze code performance. Later chapters explain how to build interpreters, parse code, and check types. There are many exercises and examples. The book is based on over 20 years of university teaching, with many authors contributing. It also has more than 200 YouTube videos to help students learn.

In the Hacker News comments, some people praise the book for being clear and well-organized, saying it helps them understand both OCaml and functional programming. Others like that it is free and open, with lots of videos and exercises. A few users say they wish more universities used OCaml instead of older languages like Java or C, because functional programming ideas are useful for many modern programming problems. Some commenters note that OCaml can be hard to learn at first, especially if you only know object-oriented or procedural languages, but this book makes the learning curve easier. One person points out that functional programming can seem strange at first, but it teaches you to think about problems in a new way. Another user says the book's style helps them write better, more reliable code. There are also some who prefer Haskell or other functional languages, but agree that OCaml is a good choice for teaching. A few discuss the license and mention that while you can't sell or change the book, it's still a great resource for learning. Overall, most agree this is a strong, free textbook for anyone who wants to learn OCaml or functional programming.

---

## How We Rooted Copilot

- 原文链接: [How We Rooted Copilot](https://research.eye.security/how-we-rooted-copilot/)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44695098)

Microsoft Copilot Enterprise got a backend update in April 2025, letting it run live Python code through a Jupyter Notebook sandbox. The researchers found it was pretty easy to get Copilot to run their own code inside this sandbox, sometimes by using special Jupyter commands. The system runs as the 'ubuntu' user, who is in the sudo group, but there’s no 'sudo' command, so full admin access seemed blocked at first. The container uses modern Python and kernel versions and runs extra services like Tika. Network access is limited, and files are handled in a special way, with downloads and uploads going through certain directories.

Most commands are run with limited user rights, but after poking around, the researchers saw a problem in the 'entrypoint.sh' startup script. This script, run as root, uses the 'pgrep' command without a full path, and the search path ($PATH) includes writable directories before the system default. By placing a fake 'pgrep' script in these writable paths, they could make the root process run their code, gaining root access inside the container. With this, they could explore the container fully.

Even with root, there wasn’t much to find—no sensitive files, logs, or a way to break out of the container, since Microsoft had patched known escape routes. The researchers reported the bug, which Microsoft quickly fixed. The issue was marked as “moderate” risk, so there was no bug bounty, only public thanks. The team teased that they found a way into an internal Microsoft admin panel using a different OAuth trick, inviting people to see their Black Hat talk for more details.

Commenters on Hacker News had a range of opinions. Some praised the researchers’ curiosity and detailed write-up. Others pointed out that running code in cloud sandboxes is always risky, and this is a good reminder to be careful. A few readers wondered why the path vulnerability happened, as it’s a common mistake, and thought Microsoft should be more careful with scripts running as root. Some asked if the real danger was low, since the exploit only gave root inside the sandbox. Others said this shows why containers must be well-isolated and regularly updated. There were questions about Microsoft’s bug bounty rules, with several people saying moderate bugs should get some reward. Some users liked the playful tone of the article, while a few worried that “AI” products are rolling out too fast, missing security basics. Overall, the comments showed respect for the research and some concern about cloud security habits.

---

## Purple Earth hypothesis

- 原文链接: [Purple Earth hypothesis](https://en.wikipedia.org/wiki/Purple_Earth_hypothesis)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44665644)

The article talks about the Purple Earth hypothesis, which is the idea that early life on Earth may have been purple, not green. This is because the first photosynthetic organisms could have used a molecule called retinal, instead of chlorophyll, to capture light.

Retinal is a simple molecule that can absorb light in the green-yellow part of the spectrum and reflects red and blue, making things look magenta or purple. Chlorophyll, the molecule that makes plants green today, works differently—it absorbs red and blue light, but reflects green. The hypothesis says that billions of years ago, before Earth’s atmosphere had much oxygen, these retinal-based microbes might have covered much of the planet, giving it a purple color. Evidence for this includes the discovery of ancient cell membrane parts from archaea, a group of microbes that still use retinal today. For example, modern Haloarchaea live in salty environments and use a retinal protein called bacteriorhodopsin to harvest light energy. This process is simple and does not make oxygen.

Later, other microbes evolved to use chlorophyll. When they started using water for photosynthesis, they made oxygen as a byproduct. Over millions of years, this oxygen changed the atmosphere and led to new types of life, like green plants and algae. These changes also caused old purple microbes to lose their place and pushed them into smaller, low-oxygen areas. Today, purple and green microbes can still live together in places like microbial mats, where they each use different parts of sunlight.

The hypothesis also has ideas for searching for life on other planets. Scientists usually look for planets with green-yellow reflections, thinking they might have chlorophyll. But if retinal-based life is common, we should also look for planets that reflect blue and red light.

Many people in the comments found the Purple Earth hypothesis fascinating and liked the idea that early Earth could have looked so different. Some thought it made sense because retinal is a simpler molecule than chlorophyll and may have evolved first. Others pointed out there is still not enough hard evidence—much of the story is based on what is possible, not what is proven. Several readers discussed how evolution might have pushed green plants to reflect green light because purple microbes already used up the green-yellow energy. Some commenters liked thinking about what alien worlds might look like and how life there could be purple, red, or even another color. A few people mentioned that the hypothesis is a good example of how science tries to explain old puzzles with new ideas, but more research is needed. Others were skeptical and said the geological record does not show clear proof of a purple Earth. Some also noted that finding signs of retinal pigments on exoplanets will be very hard with today’s technology. Finally, a few pointed out that the story is a fun way to see how life can shape a planet’s appearance in surprising ways.

---

## Rust running on every GPU

- 原文链接: [Rust running on every GPU](https://rust-gpu.github.io/blog/2025/07/25/rust-on-every-gpu/)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44692876)

This article is about a demo project that lets you write one Rust program and run it on almost any GPU or even on the CPU. Normally, GPU programming means writing special code for each vendor, but here, you write plain Rust and it works everywhere.

The demo covers platforms like NVIDIA (CUDA), AMD/Intel/NVIDIA (Vulkan SPIR-V), Apple (Metal), Windows (DirectX 12), browsers (WebGPU), and a CPU fallback. The project uses three main tools: Rust GPU (for SPIR-V), Rust CUDA, and Naga (for converting between GPU languages). These tools used to be separate, but now they can work together. The demo sorts numbers using a bitonic sort, and the same sorting code runs on every platform.

You pick which GPU backend you want with Rust’s feature flags. For example, adding `--features wgpu` uses the wgpu library, which chooses the best available GPU driver. You can also target CUDA directly for NVIDIA cards or Vulkan on any platform. The demo bundles the GPU code into the binary at build time, so you don’t need to load anything special at runtime.

The article also explains how the Rust language helps here. Using `no_std` means you can write code that works without the standard library, which is needed for GPU code. Conditional compilation lets you write code for different platforms in one place. The author uses newtypes and enums to make the code safer and easier to understand. Rust traits and generics let you write flexible code that works for different types, with no performance loss.

Inline functions help make GPU code as fast as possible. Structs group related data to keep things organized and safe. Rust makes it easy to control memory layout, which is important when sharing data between CPU and GPU. Pattern matching, generics, derive macros, and Rust’s module and workspace system all help keep the code clear and maintainable.

Testing is much easier than with normal GPU programming. You can test and debug the kernel code on your CPU with normal Rust tools, saving time and making bugs easier to find. Rust’s build scripts, formatting, linting, and documentation tools all work for this project, so you get the same developer experience as regular Rust code.

There are still rough edges. The GPU backends are not part of the main Rust compiler, and you need nightly Rust and special toolchains. Debugging is sometimes hard, and the APIs for CUDA and SPIR-V are not unified yet. The author wants to make everything smoother and invites others to help.

Commenters on Hacker News had lots of thoughts. Some people are excited, saying this could make GPU programming much easier and more fun. They like that you can use one language everywhere and avoid rewriting code for each GPU vendor. Others point out that performance tuning is still needed, and that real-world GPU code often relies on vendor-specific tricks for speed. A few are worried about the setup, since you still need special compilers and toolchains, which can be hard for beginners.

Some users ask about debugging and wonder if it's really possible to find and fix GPU bugs with normal tools. Others share that being able to test on the CPU first is a big win. There are questions about how well this will work for complex graphics or deep learning code, since those often push hardware to the limit. Some also wonder when these features will land in stable Rust, so they don't have to use nightly builds.

One commenter notes that Rust's strict typing and safety features are a great fit for tricky GPU code, where bugs are both common and hard to catch. Others highlight that this could open up GPU programming to more people, not just experts. There's hope that, as APIs and tooling get better, more projects will move to this model. But some warn that for now, it's still rough, and not quite ready for big production work. Everyone agrees, though, that this is a big step forward and a sign that GPU programming in Rust is getting much closer to everyday use.

---

## Large ancient Hawaiian petroglyphs uncovered by waves on Oahu

- 原文链接: [Large ancient Hawaiian petroglyphs uncovered by waves on Oahu](https://www.sfgate.com/hawaii/article/hawaii-petroglyphs-uncovered-20780579.php)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44654031)

Waves on Oahu have washed away sand and showed large old Hawaiian petroglyphs. These are carvings made in rock by people from Hawaii a long time ago. The carvings are very big, and some are over three feet tall. They show human shapes and simple designs. The petroglyphs were hidden under the sand for many years. Local people and experts did not know so many petroglyphs were there. Now, everyone is excited to see them.

The article explains how these petroglyphs are important to Hawaiian culture. They show how ancient Hawaiians lived and told stories. Experts are taking photos and notes to study them before the waves cover them again. The petroglyphs could be hundreds of years old. People are careful not to touch or step on them, because they can break easily. Sometimes, the sand covers them again, so they are not always visible. The government and local groups want to protect these carvings.

In the comments, some people are amazed that such history was hidden for so long. Others talk about how nature, like waves and wind, can uncover or hide history. One person worries that too many visitors might damage the site. Another says it is good for science and for Hawaii’s story. Someone hopes local people can lead the work to keep the petroglyphs safe. Others share stories about seeing petroglyphs in other places. A few wonder how many more secrets are still hidden under the sand. Some think technology, like drones and cameras, could help find more sites. Many agree it is lucky these carvings were found before they disappeared forever.

---

## The Sail instruction-set semantics specification language

- 原文链接: [The Sail instruction-set semantics specification language](https://alasdair.github.io/manual.html)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44696543)

The article explains Sail, a language for writing the rules (semantics) of how computer processors work at the instruction level. Normally, companies describe processors with a mix of natural language, tables, and sometimes code-like text, but these are not always clear or complete. Sail tries to make these descriptions precise, clear, and easy for both people and computers to read and check.

Sail is designed to look like the code style used in ARM and IBM Power manuals. It helps engineers write exact rules for how each instruction should work, including complex memory behaviors. Sail has a strong type system that helps catch mistakes, especially with bit lengths and indexes, which are common in processor design. It can also turn these rules into code that runs (for testing or emulation) and into files for formal proof tools, like Isabelle, HOL4, and Coq, for deep checking.

A Sail file usually defines types for instructions, functions to decode binary data into instructions, and functions to run those instructions. Once written, Sail can check the code, run it, or turn it into C or OCaml code, or even SystemVerilog (for hardware checking, though this feature is new). Sail has been used for ARM, RISC-V, MIPS, and CHERI processor models. Some models are written by hand, others are translated from company specs.

The article gives a simple example from RISC-V, showing how to define instructions like “add immediate” and “load double.” It shows how to set up types, registers, memory, and how to write the rules for decoding and running instructions. Sail code can be organized into modules for big projects, and has features like formatting, an interactive interpreter, and conditional compilation.

Sail supports many features: strong types, pattern matching, user-defined types (structs, enums, unions), vectors, bitfields, exceptions, and more. It also allows overloading functions, and has tools for code generation and formatting. The language is inspired by OCaml, Rust, and other functional languages, but keeps close to hardware specs.

In the Hacker News comments, many readers liked that Sail makes CPU specification more exact, and helps avoid mistakes that happen with unclear specs. Some users said formal tools like Sail can help catch tricky bugs, and make it easier to prove things about hardware. A few developers shared that they use Sail or similar tools for work on RISC-V or ARM, and like being able to generate emulators and proofs from one source.

Others wondered about the learning curve—Sail has strong types and a functional style, which can be hard if you are used to only C or simple scripting languages. Some people asked why not use more common languages, or if Sail can be used for other hardware, not just CPUs. There were comments about how Sail compares to other spec languages, like Bluespec or Chisel, and questions about tool support and documentation.

A few people pointed out that while Sail is good for formal specs and proofs, it might be too complex for small projects, or for people who just want to write simple, practical code for real hardware. Some liked the idea of being able to run the spec directly as a test, while others thought the code examples looked a bit strange or verbose. Overall, most agreed that clearer, machine-checkable specs are a good step for reliable hardware and software.

---

## Epic Recall, Epic Fail

- 原文链接: [Epic Recall, Epic Fail](https://taipology.substack.com/p/epic-recall-epic-fail)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44696973)

The article talks about the failed recall election in Taiwan, where the ruling DPP party tried to remove 24 KMT opposition legislators but did not succeed with any of them. The writer expected the recalls to work, especially since the rules make recalls easy and the DPP was very organized, but even the “easy target” KMT legislator survived. 

The recall effort came after the DPP lost control of the legislature in the last election and hoped to win back seats by recalling KMT lawmakers. The author calls these “Sore Loser recalls” because they were not about corruption or bad behavior, but just about losing the previous election. The article says people are tired of constant elections and political fighting, with another round of recalls coming soon but likely to also fail. The DPP tried to use slogans about “protecting Taiwan” and fighting China, but many feel this argument is old and used too much.

President Lai Ching-te made a speech comparing recalls to removing impurities from iron to make steel, but people made fun of this incorrect science. At an anti-recall rally, people wore shirts saying “I am the impurity,” showing they were upset about being called “bad” for disagreeing with the DPP. The TPP, Taiwan’s third party, stood with the KMT against the recalls, even though its own members were not being targeted. The writer thinks this new unity between KMT and TPP helped them win.

Now, the KMT lawmakers cannot be recalled again for two years, but the DPP could face recalls if the KMT gets organized. The article ends by saying people want the government to work together and stop fighting, but this result may lead to even more gridlock and anger.

Hacker News commenters had many opinions about the recall. Some thought recall elections should be rare and only for serious problems, not just for losing a vote. Others said the DPP’s focus on anti-China messaging is wearing thin and voters want politicians to work on local issues instead. A few users were surprised the recalls failed, since the DPP’s campaign seemed well-organized and public. Some commenters pointed out that constant elections and recalls make people tired and less likely to vote, which can hurt democracy. Others discussed how the TPP’s role as a middle party is changing as they work more with the KMT, possibly making politics more divided. Some commenters warned that if the recall process is abused, both sides will keep using it for revenge and nobody will get real work done. A few saw humor in the “impurity” slogan and President Lai’s metalworking mistake, saying politicians should be more careful with their words. Other users said the failed recalls might actually help the KMT and TPP, making them stronger against the DPP in the future. Overall, the comments showed people want less fighting and more focus on real problems, but worry that politics will only get more heated.

---

## Getting decent error reports in Bash when you're using 'set -e'

- 原文链接: [Getting decent error reports in Bash when you're using 'set -e'](https://utcc.utoronto.ca/~cks/space/blog/programming/BashGoodSetEReports)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44666984)

This article talks about how to get better error messages in Bash scripts when you use ‘set -e’ to stop the script after an error. The author explains an easy way to show what went wrong, where it happened, and which command failed.

The main trick is to add this line near the top of your script:  
trap 'echo "Exit status $? at line $LINENO from: $BASH_COMMAND"' ERR  
This command uses Bash features:  
- $LINENO tells you the line number where the error happened.  
- $BASH_COMMAND shows the command that was running.  
- $? is the exit status of the last command.

The ‘trap’ command listens for the ERR signal, which is sent when a command fails. Using ERR is important; if you use EXIT instead, you get the line number of the trap itself, not the line where the error happened. This makes error messages less useful.  

The author says this works well in Bash, but not in other shell programs. For example, in OpenBSD’s /bin/sh, you can get the line number, but not the command. In FreeBSD’s /bin/sh, you only get the exit code because $LINENO is wrong. On Ubuntu’s Dash shell, you can’t get the line number at all. On Fedora, /bin/sh is actually Bash, so it works, but you should still write your script for Bash if you use these features.

People in the comments liked the idea and shared their own ways to get better error messages. Some said they use more advanced error handling or even different programming languages for better control. A few worried that ‘set -e’ can act in strange ways and sometimes skips errors, so you should test scripts well. Others reminded readers that Bash-only features can break scripts on some systems and suggested using ‘#!/bin/bash’ at the top to be clear. Some users said they prefer using strict flags and error handling together for the best results. A few mentioned that for big or critical scripts, using a tool like Python might give even better error reporting. There were also tips about making error messages even more detailed, or writing logs to a file. People agreed that knowing exactly which line and command failed saves a lot of debugging time. One or two users pointed out that, for very portable scripts, you might have to live with less helpful errors. Overall, the comments showed that many people care about clear error messages and shared their own simple tricks to help.

---

