Hello everyone, this is the 2025-08-15 episode of Hacker News Daily Podcast. Today, we bring you stories about Git’s new large file support, the future impact of AI, saving money on cloud infrastructure, clever hacks for gym entry, rare occult books online, startup advice from Paul Graham, a surprise OpenBSD benchmark, new AI tools for embedded development, Apple’s TextKit 2, and open-source firmware on AMD’s latest CPUs. Let’s get started.

First, Git is getting much better at handling large files, and this may mean we will not need Git LFS for much longer. Right now, large files make Git slow and take up a lot of space, so many teams use Git LFS as a workaround. But Git LFS has its own problems: it stores big files outside the main repo, so clones are faster and smaller, but it adds extra costs and setup steps, and once you start using it, it’s hard to go back. If your team does not all set up LFS, you can get confusing file errors.

The article explains Git’s new partial clone feature. With this, you can clone a repo without downloading all big files at first. You set a filter to skip files over a certain size, and Git only downloads them later if you need them. In one test, cloning a repo with a single large file was 97% faster and used much less space than before. There are still downsides: if you need the big files later, Git must fetch them, which is similar to how Git LFS works. But partial clone does not lock you to one vendor, is cheaper, and does not require every user to install extra software.

Git is also adding a feature called large object promisors, which will let servers store big files in a special way. This should make things easier and cheaper for both users and hosts. In the future, pushing big files to places like GitHub may become much simpler.

In the comments, many users are happy with these changes and think partial clone is a big step forward. Others warn that not all Git hosts or tools fully support partial clone yet, so some workflows might break. Some share painful stories about moving away from Git LFS, while others say LFS never fit their projects. There’s also debate about whether big files belong in Git at all—some say it’s better to keep large binaries elsewhere. People are curious about large object promisors but want to see real-world support before switching. Some worry about old tools and the learning curve. But most agree these updates are good news and hope that in time, Git LFS will no longer be needed.

Next, we turn to the future of artificial intelligence. This article says AI is not like past technologies and could change the world in new ways. Today, AI can do things that seemed impossible a few years ago, such as understanding language, writing code, and even finding bugs that skilled programmers miss. Large language models are still a mystery, even to experts, so it’s hard to predict what will happen next. Progress may slow, but if it does, it will likely lead to more research and ideas.

The author warns that if AI keeps getting better and can work with little help from humans, the results will not look like older tech revolutions. Investors hope AI will just bring more business like the internet or smartphones did, but this may not be true. If AI replaces many workers, our economy could face big problems. Companies might stop paying for outside services if their own AI can do the work. It’s hard to imagine a world where only a few giant companies control all AI, so maybe AI will become something anyone can use, or governments will step in.

The future could mean less economic growth and maybe a new kind of economy. Stocks are still rising, but the author says markets may not see what is coming. AI could change everything, just like new knowledge changed whole systems in the past.

On Hacker News, some people agree AI is moving fast and the future is hard to guess. Others remember old hype cycles and wonder if AI will slow down too. Some hope AI will free people from boring work, but others worry about jobs and risks. There is debate about whether AI will become a public good or stay under control of big firms. Many want governments to create new rules. Some think past tech changes might help us understand what’s coming, but most feel AI is different. People are both excited and worried, and agree that we should be ready for surprises.

Now, let’s look at Edka, a service that helps you run Kubernetes clusters on your own Hetzner account. Edka claims you can cut your cloud costs by up to 70% compared to AWS or GCP, while keeping full control over your servers. You can set up a full Kubernetes infrastructure in less than two minutes, and you pay Hetzner directly for the cheaper servers. Edka adds a control panel, easy upgrades, scaling, backups, and supports GitOps workflows and built-in monitoring. You pay a flat fee per cluster, but the first cluster is free. If you want to leave Edka, you can detach it with one click and keep your servers running.

The article gives real examples: Aicole, a French startup, saved 64% after moving from Azure to Edka. Another company, TROI Ticketing Solution, saved 72% and made it easier for their developers to deploy apps.

In the comments, some people love the idea, especially for those wanting to avoid high cloud prices and keep control. Others worry about using Hetzner since it’s less known than AWS or GCP, and ask about support, uptime, and security. Some like the simple pricing and free cluster, but others say Kubernetes is still too complex for small projects. There are tips about running clusters on Hetzner, with some mentioning good performance and others noting network issues. People ask about managed databases, easy backups, and migration tools. Overall, there’s interest in saving costs and owning your infrastructure, but also caution about leaving big cloud providers.

Now, for a fun story—a developer was tired of PureGym’s slow app and made his own Apple Wallet pass to get into the gym faster. The official app took 47 seconds and several steps to enter, but his old PIN code still worked after eight years. He tried to screenshot the QR code and add it to Apple Wallet, but the codes changed every minute. He found that the app’s API was not very secure—his eight-digit PIN was also his API password. Using mitmproxy, he watched the app fetch new QR codes every minute.

He learned that Apple Wallet passes can update themselves and pop up on the lock screen near the gym. So he built a backend in Swift using Vapor to generate and update the Wallet pass, letting his phone or watch always have the latest QR code. He scraped gym locations so the pass would appear at any PureGym. Now, he gets in with a tap—just three seconds instead of 47. Over a year, he saves about four hours. He also pulled gym capacity data for his Home Assistant dashboard.

He knows he’s bending the rules, but only uses it for himself and is ready if PureGym blocks it. He jokes maybe they should hire him, and says users care more about simple, fast experiences than company plans.

In the comments, many praise the cleverness of the project, and some are sad that one person could do what the company did not. Others joke about the weak security, and a few warn about breaking terms of service. Some wish more companies would use Apple Wallet or similar tech, and others debate if this kind of hacking is good for the industry. Many would like to see this as an official feature, but agree legal issues make it hard. There are also comments about Apple’s PassKit system and how few people use it. Overall, people enjoyed the story and hope companies notice how much users care about simple, fast solutions.

Next, Amsterdam’s Ritman Library has put 2,178 old occult books online, thanks to help from Dan Brown, the author of “The Da Vinci Code.” These books cover alchemy, astrology, magic, and more, most written before 1900. The project, called “Hermetically Open,” started in 2018 to make rare books available to all. The books are in many languages, mostly Latin, but also German, Dutch, and French. English readers can search for some books published in London or Cambridge.

The books have strange titles from the 1600s and are full of old language and odd ideas. If you expect easy “magic recipes,” you may be surprised—many books talk about matching plants, animals, and stars, or long talks about numbers and symbols. Many famous thinkers, like Aleister Crowley, Madame Blavatsky, and even Isaac Newton, are linked to these ideas.

The library also has books on philosophy, religion, medicine, and science from when these fields mixed with occult thinking. For example, Henry More, a Cambridge Platonist, tried to combine Plato’s views with Christianity and early science.

In the comments, people joke about so many occult PDFs now being free. Others talk about the value of saving rare books and making them open, even if the topics seem strange. Some are excited to read these texts for fun, while others talk about the history of science and how “occult” ideas shaped real science. A few wish for more translations into English, and some warn that old magic texts are much more complex than modern stories. Most see the project as a great way to share rare knowledge and learn about the history of ideas.

Now, let’s talk about startups. Paul Graham explains why early startups should do things that don’t scale, even if it feels slow or messy. Startups do not “take off” on their own—founders must push hard at the start. He says you should recruit users one by one, like Stripe did by setting up accounts directly for new users, or how Airbnb’s founders went door-to-door in New York. Actions like this seem small, but are key for growth.

Most startups are fragile at first. Founders should not compare themselves to giant companies, but ask, “How big could this be if we do the right things?” The right things can look unimportant, like sending handwritten notes or helping one user at a time. For example, Wufoo sent handwritten thank-you notes, Pinterest’s founder went to design conferences, and Facebook started with just Harvard students. Hardware startups built first products by hand before affording factories.

Graham says to over-deliver for early users—they will become fans who tell others. This is easier for small startups, so use your small size as an advantage. Sometimes, you can “fake” automation by doing things manually until you build the real system.

He warns against launching big or making big partnerships too soon. Success usually comes from slow, steady growth and making users happy.

In the comments, many agree that doing things that don’t scale is key for new startups. Some share stories of helping users by hand, while others warn that too much manual work can distract from building better products. Some say this advice fits best for consumer or small-business startups, but not all businesses. Others say over-delivering helps create loyal fans. There are stories about how manual work taught founders what users wanted, and questions about when to move from manual to automated systems. Some warn the biggest risk is giving up too soon, while others say founders should watch for signs that their market is too limited. Most agree: do things that don’t scale, but keep learning from your users and stay flexible.

Next, an article shows a small benchmark where OpenBSD runs a program much faster than Linux. The test makes two threads, each creating 256 network sockets, and measures the time. On Linux, it takes about 0.017 to 0.026 seconds; on OpenBSD, it takes only 0.002 to 0.006 seconds—about ten times faster. The machines are similar but not the same. The author notes OpenBSD is usually shown as slower, so this is surprising.

In the comments, some say the test is not fair because the machines are not exactly the same. Others explain that Linux may be slower due to security features like seccomp or user namespaces. Some think OpenBSD’s simple and clean code can make simple tasks faster. Others say Linux is usually faster in real-world use, but small tests can give strange results. Some want to see more benchmarks before trusting it, while others joke that benchmarks can always be found to make your favorite system look good. Some ask if this matters for real programs, since most do not create hundreds of sockets at once. Still, a few are happy to see OpenBSD win for once—a good reminder that performance depends on the task.

Let’s move to Embedder, a new tool from Y Combinator’s Summer 2025 batch. Embedder helps people write code for embedded devices using Claude, an AI language model. Coding for devices like microcontrollers is usually slow and tricky, but Embedder lets you ask Claude to write code, answer questions, and help debug. You can upload your code, give hardware context, and ask for help with drivers or protocols. It supports popular boards like Arduino and ESP32, and works in your browser. There’s a free version and a paid plan for more use. Some people already use it to save hours, and the team plans to add new features and support for more chips.

In the comments, some think Embedder is great for hobbyists and students. Others wonder if Claude really understands hardware or can debug tough problems. Some ask about privacy, since uploading code to a cloud tool might be risky. Some engineers prefer reading data sheets themselves, saying learning is part of the job. Others hope for support for more boards or languages. There are questions about how well the AI handles errors and if it can explain solutions simply. Many are interested to see if the tool can really change how people work with embedded devices.

Now, let’s talk about TextKit 2, Apple’s new text layout engine for iOS and macOS. The author spent years using TextKit 2 and building a custom text view. TextKit 2 promised easier, faster, and more flexible text handling. The design is good, with modern APIs and the ability to start simple and add features. But in practice, only Apple’s built-in classes work; custom storage and layout don’t. This limits flexibility and keeps old problems from TextKit 1.

There are also many bugs—some fixed, others open for years. A big feature, the “viewport” approach, only lays out text you see, which should make scrolling faster, but the total document height is just an estimate, so the scroll bar jumps around. Even Apple’s own TextEdit app has these problems.

The author feels the system is too hard to use for real apps. The design is good, but the details are frustrating, and TextKit 2 may not be the best choice for text editing UIs.

In the comments, many agree and share their own struggles with TextKit 2, calling it confusing, buggy, or poorly documented. Some like the viewport idea but say it’s hard to get right. A few stick to older tools, while others wish for better guides or examples. Some believe Apple often makes great frameworks but sometimes leaves them unfinished. Others hope TextKit 2 will improve as it matures. Some ask if open-source alternatives might be better for big text projects. Most see TextKit 2 as a step forward in theory, but not ready for all needs yet.

Finally, we look at open-source firmware. Developers are working to run coreboot on the Gigabyte MZ33-AR1 server board with AMD’s new Turin CPU. AMD released code for Turin CPUs to help the open-source community. The first step was to create a skeleton for the Turin SoC in coreboot, using code from the older Genoa SoC as a base, since Turin is similar but has key differences. The team had to compare files, check AMD’s docs, and set up new memory and PCI settings.

Next, they worked on the Platform Security Processor (PSP) firmware. The PSP is a small computer inside AMD chips that helps start the CPU and handles security. They used tools like PSPTool and UEFITool to extract blobs from AMD’s GitHub and from vendor BIOS images, making fixes to support Turin.

They also set up mainboard code to connect the board to the new SoC code and set up features like the serial console. They found workarounds to build a bootable image even when the public PSP blobs didn’t work yet, by copying settings from the vendor BIOS.

The article walks through the steps for extracting blobs, setting up files, and building the firmware. It ends with the first successful boot messages, though with some errors. Support for Turin CPUs in coreboot is still experimental.

In the comments, some are excited about more open-source firmware for AMD servers, calling it good for transparency and security. Others point out the process is still complex and needs vendor blobs, so it’s not fully open. Some worry about the closed-source PSP. Developers like the detailed guide, saying it helps more people learn firmware hacking. People talk about the value of open firmware for server owners, but also the challenges. Some ask if AMD will ever allow a fully open boot process, or if closed blobs are here to stay. Finally, there is praise for the teamwork between open-source developers and hardware companies, but a reminder that this is early work, not ready for production.

That’s all for today’s episode. Thank you for listening to Hacker News Daily Podcast. We’ll be back tomorrow with more stories from the world of tech, software, and startups. See you next time.