Hello everyone, this is the 2025-10-02 episode of Hacker News Daily Podcast. Today, we have three stories about blogging tools, programming languages, and CPU design. Let’s get started.

Our first story is about a writer who uses Emacs with Org mode and Babel for blogging. Even though this setup is very complex, the writer keeps using it. They often feel jealous when they see simple static site generators, and wish their own system was easier to understand and control. The writer uses Org mode to write blog posts, and then exports them to HTML using Org publishing tools. But this whole process relies on more than 20,000 lines of Emacs Lisp code. The writer finds it hard to understand what really happens during publishing, and they cannot easily explain it to others.

Sometimes, the writer thinks about building a simple custom blogging tool—maybe with only 2,000 lines of code. That would be easier to understand and change. But they never do it, because of one main feature: Babel. Babel lets them write code blocks in their blog posts and run the code as they export. The output, like tables or images, gets included in the final post. They can even use results from one code block in another, and mix code with variables from the text. For this writer, Babel is very useful, especially for making plots with R and editing both data and text together. They say that after using this, it is hard to go back to a simpler tool.

So, even though the current setup is hard to use and sometimes breaks, Babel is powerful enough that the writer cannot leave it. They wish everything was less complex, but these features are worth it for their workflow.

In the comments, many people agree that Org mode and Babel are powerful, but also too complex for new users. Some say they prefer simpler tools, like Markdown, since they do not need to run code in their posts. A few people like having everything inside Emacs, while others think it is better to use different tools for different jobs. Some mention that Emacs and Org mode have a steep learning curve, but once you learn them, you do not want to use anything else. Others share tips for making Org publishing easier. There are also comments about writing your own static site generator—it can be fun, but keeping it working is hard. Some point out that tools like Jupyter Notebooks offer similar features, but in a different way. A few people say that if Babel is the “killer feature,” then it makes sense to stay with Emacs, even if it is complicated. Overall, the comments show respect for Org mode’s power, but also worry about its complexity.

Now, our second story is about why an author rebuilt their blog using Lua instead of more common languages like JavaScript or Ruby. The author wanted a blog system that would stay simple and work for many years without breaking. Their old setup used Racket with a lot of custom code, but it became too hard to maintain. They wanted something that did not need constant updates or changes.

JavaScript, which is the author’s main language, seemed like the easy choice. But JavaScript, Node.js, and NPM change too quickly. Old code often breaks and needs fixing. Other languages, like Ruby, have the same problem, though maybe not as much. Lua is different. It changes very slowly. Lua 5.1 came out in 2006, and Lua 5.4 in 2020, but the changes are small. Lua is also easy to set up—just a simple C compiler is enough.

The author rebuilt their blog using Lua with CGI scripts, a SQLite database, and HTML templates. They do not care about handling huge numbers of visitors—even 50,000 a week is fine for their system. Lua has fewer libraries, but enough to get the job done. The author writes many small tools themselves, keeping the code simple and easy to understand. With Lua, they do not have to worry about big changes breaking their blog. They can remember how everything works and feel sure that it will keep working for many years. Lua feels like a set of building blocks, letting them make what they want without extra things.

In the comments, some people agree that using a small, stable language is smart for long-lasting projects. They mention their own problems with JavaScript or Ruby projects breaking after a few years. Some readers say Lua is fun and easy to use for small projects. Others worry that Lua’s small library selection could be a problem for bigger needs. A few say that modern tech stacks are fast and easy, but only if you keep up with updates. One commenter thinks the author is brave for writing everything from scratch, but also says it is a good way to learn. Some people wonder if using CGI is too old-fashioned, but for a personal blog, it is fine. Others suggest languages like Go or Python, but agree that Lua is a good choice if you know it. Many comments say it is nice to see someone choose what works for them, not just what is popular. Some even say they want to try Lua after reading the story.

Our last story is about the RISC-V CPU instruction set and why it does not have a “conditional move” instruction like the aarch64’s `csel`. The author explains why this matters for programmers and CPU designers. On aarch64, the `csel` instruction can pick between two values based on a condition in one step. It is flexible and useful for many small tricks, like converting a condition to a boolean, making a mask, or computing the absolute value of a number.

RISC-V, which is a popular new instruction set, does not have a direct version of `csel`. You can use other instructions like `slt`, or use extra instruction set extensions, but these only work for special cases. The RISC-V manual says they left out conditional moves on purpose, instead suggesting the use of short branches. Some RISC-V CPU cores try to fix this by turning simple branch instructions into something like a conditional move in hardware, which is called macro fusion. But this is not always safe because of memory model rules. In RISC-V, a branch creates a control dependency for all store instructions after it. If you turn a branch into a conditional move, you lose this dependency, which can change how memory operations happen. This might break some programs.

So, even if a conditional move and a branch look the same, they are not always the same because of these memory ordering rules. CPU designers need to be careful if they want to merge branches into conditional moves.

In the comments, some people like the simplicity of RISC-V’s design, even if it is less efficient. Others wish RISC-V would add more flexible instructions like aarch64’s `csel`, to help make code faster. Some explain that the memory model problem is very important, especially for multi-core systems. A few point out that real-world performance may not change much, since modern CPUs already handle branches well. Others say that adding more instructions can make CPUs more complex and harder to verify. Some say that RISC-V’s focus on simplicity is good for open hardware projects. There are also discussions about how compilers work around these missing instructions. Some readers argue that hardware fusion might be worth it for smaller and faster code, while others warn it could cause hard-to-find bugs. In the end, people agree that it is hard to balance simplicity, performance, and correctness.

That’s all for today’s episode. Thank you for listening to Hacker News Daily Podcast. See you next time.