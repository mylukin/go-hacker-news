# Hacker News 故事摘要 - 2025-08-11

## 今日概述

Today’s top Hacker News stories talk about new ways to write code with recursion and loops, tools for making Postgres databases bigger, and OpenSSH’s move to stronger, quantum-safe security. Other stories look at the problem of organizations forgetting important knowledge, a simple daily habit for better learning, a Java library for making code at runtime, and mixing Markdown with custom web elements. If you like tech, security, programming tips, or web writing, there is something worth reading today.

---

## Why tail-recursive functions are loops

- 原文链接: [Why tail-recursive functions are loops](https://kmicinski.com/functional-programming/2025/08/01/loops/)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44837949)

This article explains how tail-recursive functions can work just like loops in programming. It shows why recursion is often slower than loops, and how using tail recursion can make recursive functions as fast as loops.

When you write a normal recursive function, each call needs to remember what to do next, so it uses extra memory on the stack. For example, to sum a list, the function keeps part of the answer in memory for each step. This means if your list is long, you use more and more stack space, which can be slow and use a lot of memory.

With loops, you do not have this problem. Instead, you use a variable (like an accumulator) to keep the running total. Each time through the loop, you update this variable. You only use a small, fixed amount of memory, no matter how long the list is.

The article then explains tail recursion. In tail-recursive functions, the recursive call is the last thing that happens. This means the function does not need to remember anything after the call. If the compiler supports tail-call optimization, it can turn the recursion into a simple jump, just like a loop, and not use extra stack space.

For example, when summing a list with tail recursion, you add an accumulator parameter and always pass the new total along with the recursive call. When you reach the end of the list, you just return the accumulator.

The article also gives examples that are harder to write with tail recursion, like counting even and odd numbers at the same time (which needs two accumulators) and flattening a tree (which has two recursive calls, so it’s not easy to make tail-recursive).

Finally, the article mentions that you can turn any function into a series of tail calls using a method called continuation-passing style (CPS), which is used by some functional language compilers to avoid stack overflows.

In the comments, some people say they prefer loops because they are easier to read and understand, especially for new programmers. Others like recursion, saying it matches the way they think about problems, and it is often clearer for things like tree structures.

A few commenters point out that not all programming languages support tail-call optimization, so tail-recursive functions can still use a lot of stack space in some cases.

Some users give examples of cases where recursion is more natural, but agree that for simple tasks like summing a list, a loop or tail recursion is better for performance.

One person mentions that learning how to turn normal recursion into tail recursion is a good exercise for understanding how programs use memory.

A few people talk about the CPS method and say it is powerful but can make code hard to read.

Some users share that in languages like Scheme or Racket, tail recursion is common and the compiler helps turn it into a loop automatically.

A commenter warns that in languages like Python, there is no tail-call optimization, so deep recursion can crash your program with a stack overflow.

Some people ask about real-world examples where CPS is used, and others answer with examples from compilers and functional programming.

A few users discuss how performance differences between loops and tail recursion matter more for very large data or performance-critical code.

Finally, some commenters just enjoy seeing the connection between recursion, loops, and how compilers work under the hood.

---

## Neki – sharded Postgres by the team behind Vitess

- 原文链接: [Neki – sharded Postgres by the team behind Vitess](https://planetscale.com/blog/announcing-neki)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44867374)

PlanetScale has announced a new project called Neki, which is a sharded version of Postgres built by the same team behind Vitess. The main goal is to help Postgres databases handle much bigger workloads by splitting data across many servers, a process known as sharding.

Vitess has already made it easier for many people to use sharding with MySQL. Now, PlanetScale wants to bring similar power and scale to Postgres. Neki is not just a copy of Vitess made for Postgres. Instead, it is being built from scratch, using new ideas and working closely with partners who run big systems. The team says Neki will be open source and ready for the most demanding Postgres tasks once it is finished.

The announcement does not give many details about how Neki will work, but it highlights PlanetScale’s past experience and explains why a fresh approach is needed for Postgres. They invite people to sign up for updates and say more information will come later.

In the comments, some people are excited about the idea, saying Postgres needs better sharding solutions. They hope Neki will be as useful as Vitess has been for MySQL. Others are curious about the technical details and want to know how Neki will handle things like transactions, consistency, and failover. A few commenters ask why not just use Vitess with Postgres, and the team explains that Vitess depends on MySQL features, so making it work well with Postgres requires new engineering.

Some users point out that sharding is hard to do right, and they hope Neki will make things simpler for developers. There are also questions about open source plans, licensing, and how much control users will have over their databases. A few people mention other sharding tools for Postgres and wonder how Neki will be different or better. Others share concerns about adding more complexity and hope for good documentation and support. Overall, the community seems interested and hopeful, but they want to see real code and more details before getting too excited.

---

## OpenSSH Post-Quantum Cryptography

- 原文链接: [OpenSSH Post-Quantum Cryptography](https://www.openssh.com/pq.html)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44863242)

This article talks about how OpenSSH now uses new cryptography methods to protect against future quantum computer attacks. The main idea is that if quantum computers become real and powerful, they could break old encryption and read secret messages.

OpenSSH started using post-quantum key agreement algorithms by default in version 9.0 with sntrup761x25519-sha512. Later, they added mlkem768x25519-sha256 in version 9.9, and made it the default in version 10.0. If you connect with an older, less secure algorithm, version 10.1 will now give you a warning. You can turn off this warning if you want, but the project recommends using the new algorithms.

Quantum computers can solve special math problems much faster than normal computers. This could let someone break the encryption used to keep SSH connections private. Even though strong quantum computers do not exist yet, attackers could save your encrypted data now and decrypt it years later, when they do get such computers. This is called a "store now, decrypt later" attack.

To stay safe, OpenSSH supports these new post-quantum methods. If you get a warning, it means the server you are using is not safe against quantum computers. You should update your server, or change the settings, so it uses the new key agreement algorithms. If you cannot update, you can silence the warning, but that is risky.

The article also talks about digital signatures. These, too, could be broken by quantum computers. But unlike key agreement, attackers cannot use old data later, so there is less risk for past messages. OpenSSH plans to add new signature algorithms in the future.

Some people say quantum computers may never exist or be this strong. The article admits this could be true, but says it is better to be safe. If quantum computers never work, nothing is lost—just better algorithms. The team picks hybrid algorithms that mix old and new, so even if the new part is broken, the connection is still as safe as before.

In the comment section, some people like these changes and say it is smart to prepare early. They mention that adding warnings will help users notice problems before it is too late. Others worry the new algorithms are not tested enough and could have hidden flaws. A few feel that quantum computers are still far away, so there is no rush.

Some users talk about the real risks of "store now, decrypt later" attacks, especially for important government or business data. Others ask technical questions about server updates and how to check if they are using safe algorithms. A few are annoyed by extra warnings and want easy ways to turn them off. Some even wonder if these changes will slow down SSH connections or cause new bugs.

There are also comments about hybrid algorithms—most agree it is a good idea to use both old and new until the new ones are better tested. Some people are excited to see OpenSSH moving fast, while others think more time is needed for research. Many agree that even if quantum computers never work, using stronger cryptography is a good thing. A few share links to more info on post-quantum cryptography and how other software projects are handling the same problem.

---

## The Value of Institutional Memory

- 原文链接: [The Value of Institutional Memory](https://timharford.com/2025/05/the-value-of-institutional-memory/)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44866500)

This article talks about how organizations often forget important information, known as “institutional memory,” and why that can lead to big problems. The author starts with a story from 1978, where a canal crew unknowingly pulled a two-century-old plug from the Chesterfield Canal, causing all the water to drain out, because old records had been destroyed in World War II.

The article explains that losing institutional memory can cause disasters, like in this canal story. Even in places meant to save knowledge, like the Bodleian Library, information about old portraits gets lost if people don’t keep it up to date. The author gives more examples, such as Volkswagen repeating the same cheating scandal with emissions tests in both 1973 and 2015, showing they forgot past lessons. NASA’s Challenger and Columbia shuttle accidents happened years apart, but both were caused by ignoring warnings from engineers—once again, lessons from the first accident were forgotten before the second.

The article also talks about the Lockheed TriStar airplane, which stayed expensive to build because the company made so few planes that workers forgot how to build them efficiently. The idea is that organizations can forget how to do things if they don’t keep practicing. Forgetting can happen because people leave, old paper records get lost or destroyed, and digital records become unreadable over time. Sometimes, organizations even destroy records on purpose, like in the UK Windrush scandal, making it impossible for people to prove their rights. The article mentions that over 100,000 US government webpages disappeared after a change in leadership, showing that digital information can be lost quickly.

The main point is that forgetting is natural, but if organizations don’t work hard to remember, they risk losing important knowledge and making big mistakes.

In the Hacker News comments, many people agreed that institutional memory is important and shared their own stories of knowledge being lost at work. Some said that companies often rely too much on a few experienced workers and when those people leave, things fall apart. Others pointed out that writing things down helps, but only if people know where to find the documents later. A few users warned that sometimes, companies forget on purpose to avoid blame or legal problems. Some commenters argued that technology changes so fast now that it’s hard to keep old knowledge useful. Others said that even with modern digital tools, it’s easy to lose information if you don’t update storage formats.

A few readers noted that keeping too much information can be a problem too, because it gets overwhelming and hard to search. Some suggested that regular training and review sessions can help keep knowledge fresh. Others thought that company culture matters a lot—organizations that value learning from mistakes are less likely to forget important things. One person said that even good documentation is useless if new workers don’t know it exists or don’t have time to read it. Lastly, some people wondered if forgetting is sometimes good, since it lets organizations move on from old, outdated ideas.

---

## Learn, Reflect, Apply, Prepare: The Four Daily Practices That Changed How I Live

- 原文链接: [Learn, Reflect, Apply, Prepare: The Four Daily Practices That Changed How I Live](https://opuslabs.substack.com/p/learn-reflect-apply-prepare)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44865834)

This article shares a simple daily practice made of four steps: Learn, Reflect, Apply, and Prepare. The writer says these steps help them feel more calm and ready in a busy world full of quick fixes and stress.

First, the writer talks about learning something new each day. This could be from a book, a podcast, a chat, or even a walk. For them, learning means staying curious and open, not just collecting facts. When they learn, their thinking changes and they feel less stuck.

Next is reflection. The writer says it is important to think about what they learned, often by writing in a notebook. This helps them understand better, see patterns, and be honest with themselves about their thoughts and feelings.

Then comes applying. This means using new ideas in real life, even in small ways, like trying something new at work or writing a note. The writer believes that learning only matters if you use it.

The last step is to prepare for the future. This could be as simple as setting up a system, sending an important email, or even backing up files. Preparation is quiet but gives big rewards later, and the writer feels the difference when they skip it.

The writer says these steps do not make a perfect system. Sometimes, they forget one or do more of another. But coming back to these four steps helps them keep learning without getting tired, use what they know, take action without rushing, and lower their stress by planning ahead.

Top Hacker News comments show a mix of support and questions. Some readers agree that simple habits like these work better than complex tools or life hacks. Others say they struggle to keep up with daily routines and ask for tips on making these steps stick. A few people wonder if writing by hand is really better than typing, while others share their own ways to reflect, like talking to a friend or taking a walk. One commenter warns that preparing too much can feel like procrastination if it stops you from taking action. Another person notes that not every day will feel productive, and that’s okay. Some say these habits help with mental health, especially during hard times. Others suggest adding a fifth step, like “rest,” to avoid burnout. A few readers ask for examples of small ways to apply new ideas in their coding or projects. Many say they like the gentle approach and want to try it for a week, just as the writer suggests.

---

## Byte Buddy is a code generation and manipulation library for Java

- 原文链接: [Byte Buddy is a code generation and manipulation library for Java](https://bytebuddy.net/)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44839496)

Byte Buddy is a Java library that lets you create and change Java classes while your program is running. Unlike basic tools in Java that only let you create proxies for interfaces, Byte Buddy can make any class or change existing classes with an easy-to-use API.

You do not need to know Java bytecode or details about class files to use Byte Buddy. The library is simple to use but also lets experts define custom bytecode if needed. It does not leave any special marks in your code, so classes made with Byte Buddy work even if Byte Buddy is not present later. Byte Buddy works with all Java versions and depends only on the ASM library, which is a standard tool for handling Java classes.

Runtime code generation may seem like a strange idea, but it is important for libraries that need to work with code they do not know ahead of time. For example, big Java frameworks like Spring and Hibernate use this to work with plain Java objects, rather than forcing users to follow strict rules. Byte Buddy helps make this kind of dynamic programming easier and more powerful.

The library is well-known and trusted. It won the Duke’s Choice award from Oracle for innovation. Byte Buddy is used in many popular tools like Mockito (for testing), Hibernate (for databases), and Google’s Bazel (for builds). It gets over 75 million downloads every year.

To use Byte Buddy, you start by creating an instance of the ByteBuddy class. For example, you can make a new class that overrides the toString method to always say "Hello World!" with just a few lines of code. Byte Buddy also lets you transform code that is already there, and can be used to write Java agents that change any running Java application.

You can get Byte Buddy from Maven Central or GitHub and use it in many build systems. It is open source under the Apache 2.0 license. There is lots of documentation and help available online, and you can ask questions on Stack Overflow or the mailing list. Paid support and training are available, but you can use Byte Buddy for free.

In the Hacker News comments, some users praise Byte Buddy for making complex Java tricks much easier. They like that it hides the hard parts of bytecode and class loading. Others point out that Byte Buddy is important for mocking in tests and for making frameworks flexible. Some developers share stories of using it to solve real problems, such as adding features to classes they do not control.

A few people worry that runtime code generation can make debugging harder. They suggest using it carefully and only when needed. Some compare Byte Buddy with other tools like ASM and cglib, noting that Byte Buddy is simpler and more modern. There are also comments about how Byte Buddy helps with Java agents and monitoring tools.

One user mentions that using libraries like Byte Buddy can help avoid boilerplate code. Another says they learned a lot about Java internals by reading Byte Buddy’s code. Some people ask technical questions about how Byte Buddy handles class loaders and compatibility with different Java versions.

A few developers mention the challenge of keeping dependencies up to date, but most agree that Byte Buddy does a good job with this. There is also some discussion about open source support and how the creator is active and helpful. Overall, the comments show respect for Byte Buddy’s design and its usefulness in the Java ecosystem.

---

## The Joy of Mixing Custom Elements, Web Components, and Markdown

- 原文链接: [The Joy of Mixing Custom Elements, Web Components, and Markdown](https://deanebarker.net/tech/blog/custom-elements-markdown/)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44865997)

This article explains how you can mix Markdown, HTML, and Custom Elements (also known as Web Components) to make writing for the web easier and more powerful. The author uses Markdown for most of his website, which is then turned into HTML on the server before being sent to users.

Markdown is simple to write and helps avoid complex HTML, but sometimes you need more than just text formatting—like a feedback form or a subscription widget. Markdown allows you to include raw HTML, so you can write your own tags in between Markdown paragraphs. For example, you can write `<subscribe-to></subscribe-to>` between text, and the Markdown processor leaves it alone. 

Custom Elements let you define your own HTML tags that expand into more complicated HTML in the browser. So, a simple tag like `<subscribe-to>` can turn into a full form with inputs and buttons. You can also add settings to your custom tags, like changing button text, or put Markdown between the tags for extra content. This allows writers to use simple tokens that turn into rich features on the page, just like macros in Markdown, but for bigger things.

The article gives examples of forms built this way, shows how you can design your own mini-languages for content, and discusses problems, like Markdown not handling self-closing custom tags or multi-line attributes well. The author solved some of these with a small program that fixes the tag formats before processing the Markdown.

He also talks about the fun and dangers of making your own mini-languages: it can be powerful, but you may end up making things too complex. He shares some ideas about designing Custom Elements so editors only need to write what’s absolutely needed, and the code does the rest. The article finishes by discussing processing Markdown and Custom Elements either on the server or in the browser, and the trade-offs involved.

In the comment section, some users are excited about combining Markdown and Custom Elements, saying it makes content writing more flexible and powerful. Others warn that mixing too many custom tags or making your own mini-languages can get confusing or hard to maintain. A few point out that not all Markdown processors handle inline HTML the same way, so you have to test carefully. Some developers say they prefer to keep Markdown as simple as possible and avoid custom HTML, while others share similar tools or tricks they've used in their own projects.

There's debate about processing on the server versus the client. Some like server-side for speed and control, while others enjoy live Markdown editing in the browser. One commenter mentions worries about browser support for Custom Elements, but most agree that support is good now. A few share tips for avoiding errors with self-closing tags and attribute formatting in Markdown. Others are inspired by the language-design ideas, saying it’s fun to think about what information you can automate for editors. And some wonder about security, asking if letting users write raw HTML or Custom Elements could cause problems. Overall, readers find the article thought-provoking and enjoy the blend of practical advice and creative ideas.

---

