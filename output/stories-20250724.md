# Hacker News 故事摘要 - 2025-07-24

## 今日概述

Today’s top Hacker News stories talk about bringing internet to space, making software faster, a new tool for data science, and a problem in SQLite that can cause silent data loss. Other stories cover a simple way of programming, the power of Visa and Mastercard, using type systems to catch bugs, a safety pause for a military pistol, and North Koreans getting tech jobs in the US with fake IDs. There is a mix of tech ideas, safety talks, and stories about how people use and misuse systems.

---

## Inter-Planetary Network Special Interest Group

- 原文链接: [Inter-Planetary Network Special Interest Group](https://www.ipnsig.org)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44675553)

The article talks about the Inter-Planetary Network Special Interest Group (IPNSIG), a group working to bring the internet into space. It was started in 1998 by Vint Cerf and other experts from NASA and universities and is now part of the Internet Society.

The main goal of IPNSIG is to help build an internet that connects planets, not just people on Earth. They want everyone, even those in space, to have internet access. This matches the goal of the Internet Society to connect unpopulated and faraway places. The group has created reports that explain how a Solar System-wide internet could work. These reports talk about the architecture (how things are built), rules, and strategies needed for a space internet. IPNSIG also works to bring together scientists, engineers, and other people who are interested in space networking. They promote new technology called Delay/Disruption-Tolerant Networking (DTN), which helps data travel over long distances, even when connections are slow or broken. Their vision is to make sure that, as humans travel to other planets, they can stay connected.

In the comments, some people are excited and think this project is important for the future of space travel. They say it’s good that the team is planning early, before humans live on other planets. Others are curious about the technical problems, like time delays when sending messages from Earth to Mars. Some commenters ask how security and privacy will work in space. A few people mention that current satellites already have similar networks, but a real interplanetary internet is a much bigger challenge. There are questions about who will pay for and control the space internet. Some wonder if companies or countries might fight over it. A few think this project is too early or not needed yet, but others think it's smart to start now so we are ready for the future. Overall, people agree that if humans go to space, good communication will be very important.

---

## I wasted weeks hand optimizing assembly because I benchmarked on random data

- 原文链接: [I wasted weeks hand optimizing assembly because I benchmarked on random data](https://www.vidarholen.net/contents/blog/?p=1160)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44632674)

This story is about a developer who tried to make a Java system faster by hand-optimizing part of its assembly code. He focused on VarInt encoding, which is a smart way to store numbers using fewer bytes when the numbers are small.

He worked in a place where every tiny speed improvement mattered because the software ran on hundreds of thousands of computers. The codebase was already very fast, so finding new ways to make it even faster was hard. He chose to work on VarInt encoding because it still used some CPU time and might be improved.

VarInt (ULEB128) is used in many data formats to save space. It turns numbers into a series of bytes, using only as many bytes as needed. Small numbers use one or two bytes, while big numbers use more. The system’s code used a Java method to encode these numbers into bytes.

Normally, people think this code is too small to speed up by using assembly language. But the team was excited to try, since they could change the Java Virtual Machine itself and wanted to show off their skills. The developer wrote new assembly code using special CPU features (like BMI2 and AVX2 instructions), making the encoder branchless and using SIMD for speed.

He tested his new code against the old Java version using billions of random numbers. The result looked great: his code was four times faster. He spent weeks making it perfect and adding it to the system.

But when he tested it in real production, there was no improvement at all. He checked and found out why: the test data was not like the real-world data. Random numbers are usually big, so they needed the encoder to work harder. Real numbers from actual use (like “60”, “19”, “1”, etc.) are much smaller and only need one or two bytes. The old Java code was already fast for these small numbers, so his fancy code did not help.

He learned that testing with random data gave the wrong idea about performance. When he changed his test to use mostly small numbers, the speedup disappeared. In the end, he removed his changes and treated the work as a lesson in benchmarking and optimization.

People in the comments had many interesting thoughts. Some agreed this was a classic mistake: testing with random data often does not match real-world usage. Others said they had made similar errors, and that it’s easy to waste time chasing improvements that only help in rare cases.

A few readers pointed out that it’s important to profile real data before spending time on hard optimizations. Some said benchmarks should always match real workloads, or else they’re useless. Others joked about how fun it is to try new CPU instructions, even if they don’t really help.

Some commenters warned that hand-optimizing can make code harder to read and maintain. Others said it’s still good to experiment because you learn a lot, even if the final result isn’t used. A few people shared that, in some rare cases, fancy optimizations do pay off, but only when you really understand the data.

A couple of readers discussed the difference between theoretical best cases and practical needs, saying it’s easy to forget that most real data is simple and small. Some said that engineers often want to play with new tech for its own sake, not because it’s truly needed. Finally, a few people thanked the author for sharing his mistake, saying everyone can learn from it.

---

## Positron – A next-generation data science IDE

- 原文链接: [Positron – A next-generation data science IDE](https://positron.posit.co/)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44634598)

Positron is a new, free tool for data science made by Posit, the company behind RStudio. It is an IDE, or coding environment, that lets you write and explore code in many languages. The aim is to help people work with data, write code, and share results easily.

Positron is built on top of VS Code, which means it looks and feels familiar to many developers. You can use it to write code in several languages—not just R, but also Python, Julia, and more. It is designed to be flexible, so you can add features or tools you need. Positron helps you keep your work reproducible, meaning others can follow your steps and get the same results. There are guides to help you get started, choose the right language interpreter, and use features like the Data Explorer. The tool is free to use, but it uses the Elastic License 2.0, which is not a full open-source license. The website has FAQs and user guides to answer common questions and help new users.

In the Hacker News comments, some users are excited and say it’s great to see a modern IDE focused on data science. People like that it supports many languages and is built on VS Code, which is already popular. Some users are happy that it is free and hope it will lower barriers for new data scientists. Others express concern about the Elastic License, noting it is not as open as MIT or Apache, and wonder if this will limit community support or contributions. A few mention they miss the simplicity of RStudio and worry that Positron might feel heavy or complex. Some users like the idea of reproducible research and think Positron will help with sharing and publishing work. There are questions about how well it handles big data or remote servers, and whether it will work for both solo users and teams. A few people point out that competition is good, and hope Positron will push other tools to improve. Some express hope that Positron’s extensibility will let them add their favorite tools or plugins. Overall, the community is interested but divided, with some excited for the future and others cautious about the changes.

---

## PSA: SQLite WAL checksums fail silently and may lose data

- 原文链接: [PSA: SQLite WAL checksums fail silently and may lose data](https://avi.im/blag/2025/sqlite-wal-checksum/)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44671373)

This article explains a problem with how SQLite handles checksums in its WAL (Write-Ahead Logging) mode. If there is a checksum error in the WAL file, SQLite just drops that frame and all the frames after it, even if those later frames are actually fine. This can lead to data loss, and SQLite does not give any warning or error when this happens.

WAL mode is used in SQLite to allow faster writes. When you write data, it first goes to the WAL file before moving to the main database file. Each write to the WAL is called a frame, and each frame has a checksum that depends on the one before it. If one checksum is broken, all following frames are ignored.

Checksums are only checked when SQLite rebuilds its WAL index, which happens if the `.db-shm` file is missing or if there was an unclean shutdown. For example, if your computer crashes while writing, the next time you open the database, SQLite will check the WAL file. If it finds a bad checksum, it will drop that frame and everything that comes after, even if there is no real problem with the other frames.

The author does not like this behavior, as SQLite does not even show an error message. This means you could lose data and not know why. The default behavior is to quietly drop data instead of telling the user or giving an option to recover. The article suggests that it would be better if SQLite gave an error and let developers decide what to do.

The article also says this behavior may be because SQLite is used a lot in embedded systems (like phones or small devices), where it is better for the program to keep running instead of crashing. Still, the writer thinks users should at least have a choice.

Looking at the Hacker News comments, some people agree that silent data loss is a big problem and that databases should make corruption more visible. Others say that this is a trade-off: on small devices, it is better to keep running, even if some data is lost, rather than crashing and making the app unusable. Some users point out that most people do not check the return codes or logs from SQLite, so even if SQLite gave warnings, many apps might ignore them.

A few commenters share their own stories of data loss from silent database errors, saying that it is hard to trust a system that does not warn you. Some developers say this is one reason they use other databases with stronger safety options, or that they add extra checks and backups to protect their data.

Others defend SQLite, saying that for most use cases (like apps on phones), this design keeps things simple and working for users who do not care about every last bit of data. A few people also mention that other databases can have similar problems, especially when used with cheap hardware.

One comment suggests that database software should have an easy way to switch between “safe” and “fast” modes, so developers can choose. Another person notes that the SQLite team is very careful and documents these choices, but maybe they could make it clearer to new users. Finally, some people just did not know about this issue and thank the author for sharing the warning.

---

## Why concatenative programming matters (2012)

- 原文链接: [Why concatenative programming matters (2012)](http://evincarofautumn.blogspot.com/2012/02/why-concatenative-programming-matters.html)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44634576)

This article explains what concatenative programming is and why it matters. The main idea is that, in concatenative languages, you build programs by joining (concatenating) small functions, and function composition is the main operation, not function application.

Instead of writing code that applies functions to values (like f(x)), you write sequences of functions, where each function takes inputs from a stack and leaves results on the stack. For example, in a concatenative language, “2 3 ×” means push 2, push 3, then multiply, leaving 6 on the stack. This uses postfix notation, where the operator comes after the values.

Concatenative languages treat everything as a function, even numbers. A number is a function that takes nothing and returns itself. Functions are combined using composition, and they often use a stack for passing values. This approach makes the language simple—there are no variables, only functions and their composition.

The article shows how types work with stack polymorphism. Functions can take any stack and add or remove values, making it easy to compose functions with different numbers of arguments. The author explains that this allows returning multiple values directly, not just as tuples.

One example is comparing concatenative and functional programming. In functional languages, writing point-free (no variables) code is possible but sometimes awkward, while concatenative languages make it natural. For instance, counting elements in a list that match a rule is more direct in concatenative style.

The article also points out that concatenative languages are easy to implement and optimize, which is why they’re used in places like the Java Virtual Machine, PostScript, and Forth. They are efficient because stack operations are simple.

However, the author admits that writing some mathematical expressions can be hard and unclear in concatenative languages, because you have to manually manage the stack. Some languages like Factor add variables for these cases, but most code does not need them.

The article ends by saying concatenative programming is not perfect, but it is powerful, simple, and has unique advantages. If you want to try it, you can look at languages like Factor or Cat.

In the comments, some readers ask about the difference between concatenative and functional programming. The author explains concatenative is a special, simpler form of functional programming, focusing on composition and stacks. Others wonder if stacks and postfix notation are required; the author says stacks are just one way to implement concatenative ideas, but not the only way.

Some people point out that writing big programs in stack-based languages can be hard to read, since you need to remember the stack state. The author answers that good concatenative code should use many small functions to help with this. Another reader says using variables can be good documentation, and without them, function inputs and outputs can be unclear; the author replies that this is also true in any dynamic language.

A few commenters debate the definitions and point out that not all virtual machines are stack-based, and that some statements in the article are not always true. Some readers share that learning about concatenative languages changed how they think about programming and algorithms, and a few share their own experiments or projects.

Others discuss possible improvements, like better IDE support for stack-based languages, and suggest that seeing the stack at each point could help. There is also debate on whether the focus on function composition really makes things simpler, or just shifts the complexity.

Overall, readers found the article interesting, clear, and thought-provoking, even if not everyone agrees with all the arguments. Many thank the author for making concatenative programming easier to understand.

---

## Visa and Mastercard: The global payment duopoly (2024)

- 原文链接: [Visa and Mastercard: The global payment duopoly (2024)](https://quartr.com/insights/edge/visa-and-mastercard-the-global-payment-duopoly)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44676559)

Visa and Mastercard handle almost all payment processing outside China, controlling about 90% of the market. The article explains how these two companies became so powerful and why it is hard for others to compete with them.

The first credit cards came out in the 1950s, with Diners Club and American Express. Visa and Mastercard started a bit later, backed by big American banks. They quickly grew by making deals with banks and locking in merchants, making it hard for new companies to join the market. Even when American Express sued them for unfair practices and won, Visa and Mastercard had already become much bigger.

Their business is like owning railroads for money: everyone needs to use their networks, and starting a new network is expensive and hard. The more banks and shops join their networks, the more useful their cards become, making it even harder for any new competitor. They do not give out cards or set interest rates; they just provide the network and charge a small fee on every payment. Because of their size, their costs do not grow much as they get more users, so they can make very high profits.

In the US, Visa and Mastercard also run most debit card payments, taking a cut each time you use your card. Their networks grew because big banks gave out their cards and kept other companies out. This strong relationship with banks helped make Visa and Mastercard the only real choices for many merchants and customers.

Recently, some big companies and countries have tried to challenge this duopoly. For example, Amazon said it would stop accepting Visa in the UK to push for lower fees. In India, the government supports its own payment system called RuPay, which charges much lower fees and is now bigger than Visa and Mastercard there. Other countries have started similar systems, and digital wallets like PayPal and Apple Pay are also changing how people pay, sometimes avoiding Visa and Mastercard. But most wallets still use cards from these companies in the background.

Buy-now-pay-later companies like Klarna and Affirm are also a threat because they let people pay for things over time, which could replace credit cards for some shoppers. The article says Visa and Mastercard's future depends on how they handle new technology, changing rules, and competition from new players.

Hacker News readers have mixed feelings. Some say Visa and Mastercard are too powerful and charge too much, especially since their real costs are low now that everything is digital. Others point out that building a payment network is very hard, needs trust, and must follow strict rules, so it makes sense that only a few companies do it well. Some commenters support national payment systems like RuPay, saying they keep costs down and help local businesses. Others warn that government-run systems can have their own problems, like less innovation or more political control.

Many readers discuss the high fees that merchants pay and wonder why there is not more competition. A few note that while new fintechs look promising, most still depend on Visa or Mastercard in the background, so the duopoly is not really broken yet. Some people share that they avoid using credit cards when possible, but it is very hard because so many shops and services only accept them. Overall, the comment section shows that while people want more competition, they also see why Visa and Mastercard have stayed on top for so long.

---

## Use Your Type System

- 原文链接: [Use Your Type System](https://www.dzombak.com/blog/2025/07/use-your-type-system/)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44671484)

This article talks about using your programming language’s type system better, especially when working with things like IDs, numbers, or strings. The main idea is that using just simple types—like int, string, or UUID—for different things can cause bugs, because it’s easy to mix them up.

The writer gives an example where a function needs a UserID, but someone might accidentally give it an AccountID because both are just UUIDs. If you only use the basic uuid.UUID type, the compiler won’t help you catch this mistake. But if you make special types for UserID and AccountID, the compiler will show an error if you mix them up. This simple trick stops bugs before the program even runs.

The author also talks about a library he made for weather calculations in Go, called libwx. In this library, each measurement—like temperature, humidity, or distance—has its own type. For example, TempF is for temperatures in Fahrenheit, and TempC is for Celsius. If you try to use these types in the wrong place, like giving a function a TempF when it wants a TempC, the compiler stops you. This makes programs safer and easier to understand.

He gives another example where someone mixes up the arguments to a function, like giving humidity where temperature is expected. Again, the compiler catches the mistake because each value has its own type. The author says this method could prevent many real bugs that happen when people mix up numbers or IDs that have different meanings.

In the end, he says programmers should always use the type system to help them, even in languages like Go that don’t have super strong type systems. He finds it surprising that more people don’t do this simple thing, since it can stop so many problems.

In the comment section, many people agree with the article. Some say they use this trick in their own code and it has saved them from hard-to-find bugs. Others mention that languages like Rust and Haskell make this kind of type safety very easy, and they wish more people would use it in Go, Python, or JavaScript too.

A few commenters note that sometimes making lots of small types can make the code harder to read or write, especially for simple scripts or prototypes. Some people worry that too many types might slow down development or make it hard for new team members to understand the code. But others reply that the safety is worth it, especially in big projects.

There’s also talk about how using clear types can help documentation and make APIs easier to use. Some people say that even if a language doesn't support strong types, you can use naming rules or comments to help avoid mistakes. Overall, most commenters agree that using the type system more is a good idea, and that it’s a simple way to make code safer and clearer.

---

## Air Force unit suspends use of Sig Sauer pistol after shooting death of airman

- 原文链接: [Air Force unit suspends use of Sig Sauer pistol after shooting death of airman](https://www.nhpr.org/nh-news/2025-07-23/sig-sauer-pistol-air-force-shooting-death)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44674123)

The Air Force has stopped using the Sig Sauer M18 pistol after a young airman died from a shooting at a Wyoming base. This pause is just for the Global Strike Command, which is a large part of the Air Force, while they do a full review of the pistol’s safety.

The airman who died was 21-year-old Brayden Tyriq Lovan. He was part of security at the base and liked sports, hunting, and video games. The Air Force says they are very sad about his death and are supporting his friends and family. The M18 pistol is made by Sig Sauer, a company from New Hampshire. Almost all U.S. military branches use this pistol, as well as a similar model called the M17. These pistols are based on the P320 model, which is also sold to police and regular people.

There have been problems with these guns before. Some people say the gun can fire by accident, even when no one pulls the trigger. This has caused many lawsuits. Some courts have said Sig Sauer is not at fault, but other times judges have made the company pay damages. Sig Sauer says the gun is safe and that the complaints are not true. In fact, the company worked to get a new law in New Hampshire. This law now protects Sig Sauer from some future lawsuits about the gun’s safety.

The U.S. Army says the pistol passed hard tests and they are not worried about its safety. But there are reports of soldiers getting hurt by these pistols firing unexpectedly. While the Air Force investigates, they are giving their people a different gun to use. They are also checking every M18 pistol for any problems. The whole bomber and nuclear force in the Air Force uses this command, so the pause affects many people.

In the comment section, some people say this is not a gun problem but a training or handling problem. Others argue that reports of accidental firing are real and should be taken seriously. Some mention that the P320, the gun the military model is based on, has a history of safety complaints. A few think the lawsuits are about user error, not bad design. Others note that the Army and other groups did a lot of tests and picked this gun anyway, so it should be safe. One commenter says changing the law to shield Sig Sauer looks suspicious. Another points out that if many people report the same problem, maybe the design does need to improve. Some people say all guns can be dangerous if not handled right, no matter the brand. Others feel sad for the young airman’s family and hope the review helps prevent future accidents. There are also comments about how big companies can avoid blame, and some ask for more facts before making judgments.

---

## American sentenced for helping North Koreans get jobs at U.S. firms

- 原文链接: [American sentenced for helping North Koreans get jobs at U.S. firms](https://fortune.com/2025/07/24/north-korean-it-workers-chapman-nike/)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=44675691)

An American man was sent to prison for helping people from North Korea get jobs at companies in the United States. He helped North Koreans pretend to be from other countries so they could work for U.S. tech firms online. 

The article says he gave North Koreans fake IDs and helped them hide where they were really from. They used these jobs to earn money and send it back to North Korea. The U.S. government is worried this money could help North Korea pay for its weapons. The man also helped them set up fake accounts, use VPNs, and trick companies into hiring them. He knew what he was doing was illegal. The FBI found out by looking at computer records and tracking payments. The man was arrested, went to court, and got a sentence of over five years in prison.

Many people in the comments are surprised by how North Korea finds ways to get money from other countries. Some think the punishment is fair because he broke the law and helped a dangerous government. Others say five years is a long time and wonder if the sentence is too harsh. A few people are amazed at how smart the North Koreans were at hiding who they are. Some worry that this means companies need to check workers more carefully. Others ask if remote work makes this kind of thing easier. A few people compare this to other cases where people helped foreign countries in secret. There are some jokes about how hard it is to spot fake workers online. Some users say the story is an example of why keeping secrets safe is important. A few worry about what else is happening that we do not know about yet.

---

