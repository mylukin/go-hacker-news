# Hacker News 故事摘要 - 2026-01-13

## 今日概述

Today’s top Hacker News stories cover creative new hardware for coding and music, a company banning AI to protect human art, simple ways to build websites, and how groups make decisions. Other themes include using AI carefully for learning, visualizing code with maps, and a new, easy event log system. Many stories focus on making tech simpler, helping people learn, and keeping control over new tools. If you like creativity, learning, or building things, today’s stories have something for you.

---

## The Tulip Creative Computer

- 原文链接: [The Tulip Creative Computer](https://github.com/shorepine/tulipcc)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=46603995)

The Tulip Creative Computer is a small, portable computer you can program with Python to make music, graphics, games, or write text. It is open source, affordable, and runs on special hardware with a touchscreen, sound, and many ways to connect to other devices.

The device boots straight to a Python prompt, so you can start coding right away. Tulip has built-in tools for music synthesis, fast graphics, hardware MIDI, WiFi networking, and lets you use USB keyboards, mice, and external sensors. You can buy a ready-made Tulip, build one yourself, use it as a desktop app, or even try it online in your web browser. The hardware uses an ESP32-S3 chip, runs MicroPython, and includes a rich synthesizer called AMY, which supports many types of sound creation. It has a bright display, supports sprites and scrolling graphics, lets you edit code right on the device, and even includes a chat and file-sharing system called Tulip World. The device supports MIDI input/output, can load images, and has a built-in text editor with syntax highlighting. You can connect to WiFi, use Python’s requests library for networking, and save files from the internet. The Tulip can last hours on battery and works with many external I2C devices like joysticks or sensors. There are guides for getting started, tutorials for making music, and a full API to explore all features.

In the Hacker News comment section, many users liked the idea of a simple, programmable computer for creativity. Some people compared Tulip to old computers like the Commodore 64 or Game Boy, saying it gives a similar feeling of fun and learning. A few praised the focus on instant coding and no distractions, saying it could help kids or adults learn programming and music. Others were impressed by the open-source nature and the low price, calling it a good tool for hobbyists. One user pointed out that having a built-in synthesizer and MIDI is great for musicians. Some wondered about the limits of the hardware, like RAM and display size, but thought the trade-offs made sense for a portable device. A few asked for more details about battery life and durability, or said they would like to see more ready-made apps. Others shared ideas for new features, like better sharing online or support for more programming languages. Several people liked that you can try Tulip in the browser before buying. In general, most comments were positive, with some users excited to try Tulip themselves or share it with their kids.

---

## Games Workshop bans staff from using AI, management not excited about the tech

- 原文链接: [Games Workshop bans staff from using AI, management not excited about the tech](https://www.ign.com/articles/warhammer-maker-games-workshop-bans-its-staff-from-using-ai-in-its-content-or-designs-says-none-of-its-senior-managers-are-currently-excited-about-the-tech)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=46607681)

Games Workshop, the company behind Warhammer, told its staff they cannot use AI for making content or designs. The leaders at Games Workshop are not interested in AI and say they want to protect their human artists and the special look of their games.

The CEO said some managers are allowed to study AI, but no one is excited about it. The company’s rules say AI cannot make art, write, or design for Warhammer or other games. They are also careful about AI on work computers and phones, and they want to keep their ideas and art safe. Games Workshop is hiring more artists, writers, and designers to make sure all their stories and pictures are made by real people. This is important because the Warhammer world is famous for its unique art style, created by artists like John Blanche. Fans love this art and do not like the idea of AI making official Warhammer pictures. Last month, there was a big argument when people thought some Warhammer art was AI-made, but the company said it was just a mistake by a human. Games Workshop sells books and art that are expensive and important to fans, so they want to keep everything human-made to avoid angering their community.

Other companies, like EA and Square Enix, are using more AI and say it is important for their future. Some leaders in gaming think AI will help fix problems and make better games. But Games Workshop is different and wants to keep things the old way.

In the comments, many people support Games Workshop’s choice. They say Warhammer’s art and stories feel special because people make them, not machines. Some think AI art is boring or loses the “soul” of the work. Others worry that using AI could hurt artists’ jobs or make it easy to copy the work of real people. A few commenters think Games Workshop is only doing this to protect their copyright and business, not because they care about artists. Some people say AI might be useful for small parts of the work, like making simple ideas or checking grammar, but not for the main art or stories. There are also voices saying that AI will get better and, in the future, even strict companies like Games Workshop might use it. A few users feel that banning AI completely is too strict and could slow down new ideas. Other readers point out that fans are very protective of Warhammer and would be angry if they saw AI art in official books. Some believe that, for now, Games Workshop made the right choice to keep their fans happy and their art unique.

---

## Are two heads better than one?

- 原文链接: [Are two heads better than one?](https://eieio.games/blog/two-heads-arent-better-than-one/)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=46603111)

This article looks at a fun problem: if you have two friends, Alice and Bob, who both see a coin flip and each lies 20% of the time, can you guess the coin better by asking both, instead of just one? The idea is to see if "two heads are better than one" when both heads are a bit unreliable.

The answer is surprising. If you ask only Alice, and always trust what she says, you'll guess the coin correctly 80% of the time. If you add Bob, who is just as honest (or dishonest), your guessing accuracy does not improve—it stays at 80%. The math shows that when Alice and Bob agree, they're probably telling the truth, but when they disagree, you have no clue who's right. This "tie" cancels out any extra value you get from having two people. The author runs a Python simulation to prove this: even with two "lying" friends, your accuracy doesn't get any better.

If you add a third friend, Charlie (who also lies 20% of the time), your accuracy jumps to 90%. That's because now you can break ties—if two out of three say "heads," you trust the majority. But if you add a fourth person (David), you sometimes get a 2-2 tie again, and your accuracy does not improve over the three-friend case. This pattern continues: only an odd number of friends helps you, while adding an even one just reintroduces the tie problem.

The article links this to a real voting idea, Condorcet’s jury theorem. That theorem says that as you add more independent voters (with a better-than-random chance of being right), the group gets more likely to pick the correct answer—if you avoid ties.

In the comments, many readers liked the clear example and the mix of math and code. Some pointed out that this matches what they know from voting theory, where an odd number of voters is better. Others discussed real-world uses, like peer review, jury decisions, or distributed computer systems, where tie-breaking is important. A few asked what happens if Alice and Bob have different lie rates or are not independent; some gave examples of how that changes things. There was talk about Bayesian thinking and how you might get more confidence with more information, but only if you can break ties. Some people joked about their own "lying friends" or wondered why we trust people at all! Overall, readers enjoyed how this simple problem led to deeper thinking about groups, voting, and how we make decisions.

---

## Show HN: Nogic – VS Code extension that visualizes your codebase as a graph

- 原文链接: [Show HN: Nogic – VS Code extension that visualizes your codebase as a graph](https://marketplace.visualstudio.com/items?itemName=Nogic.nogic)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=46605675)

Nogic is a new extension for VS Code that helps you see your codebase as a big, interactive map. It turns your files, classes, and functions into a visual graph, making it easier to understand how everything connects.

When you install Nogic, you can open a special visualizer that scans your code. It shows your code structure as a tree, with boxes and lines for files, classes, and functions. You can make custom "boards" to focus on just the parts of your code you care about. The tool also creates class diagrams, showing which classes connect or inherit from each other. Another feature is the call graph, which lets you follow how functions call each other across files. You can search for things quickly, and if you change your code, the graph updates right away. To use it, you right-click on files or folders and add them to a board, double-click nodes to open files, and drag or zoom to move around the diagram.

People on Hacker News had mixed opinions about Nogic. Some users were excited because visualizing code structure can help new team members or anyone working on big projects. A few said they had tried similar tools before, but those didn't always work well with larger codebases. Others liked the idea of custom boards, saying it could help focus on just one part of a giant project. Some people worried about performance, asking if Nogic could handle very big codebases without getting slow. There were also questions about which languages are supported and whether more will be added soon. A few users said these kinds of tools are most useful for teams, but solo developers might not need them. Others pointed out that seeing all the connections can be overwhelming if a project is already very complex. Some wondered if Nogic could help spot problems, like circular dependencies, while others hoped for features like better integration with tests or documentation. Overall, people agreed that making code more visual is an interesting idea, and many were curious to try Nogic out on their own projects.

---

## How to make a damn website (2024)

- 原文链接: [How to make a damn website (2024)](https://lmnt.me/blog/how-to-make-a-damn-website.html)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=46604250)

This article is about how to make a simple website in 2024, without using complicated tools or systems. The author says many people think making a website is hard, but it can actually be very easy if you keep things simple.

The main idea is to just start by writing your first blog post in plain HTML, using a basic text editor. You do not need to use a content management system (CMS) like WordPress, or even worry about design, domains, or hosting at first. The author shows that a website can be just one page, with only HTML—no CSS or JavaScript needed. The example given is a small HTML file with a title and one paragraph. The advice is to focus on writing real content, not a fake "Hello World" post, and to skip things like setting up a GitHub repo or buying a domain until you have written something real.

After writing the post, you upload it to a server using FTP. If you do not have hosting yet, the author admits this part is boring but necessary. Once your file is online, you have a working website, even if it is plain and unstyled. The most important part is shipping your content—getting at least one real post online.

Next, the article suggests making a simple RSS feed by hand, using XML. This lets people follow your blog in RSS readers. The author gives an example RSS file and explains how to add posts to it, why it is good to use unique IDs, and why you should use absolute URLs for images. You should also link your RSS feed from your HTML pages so browsers and readers can find it easily.

After that, you can make index pages that link to your posts. Keep using just basic HTML, with simple headings and paragraphs. Once you have a few posts, you can start to add a little CSS to style what you already have. The advice is to change things slowly, making small updates over time, and not to worry about automating everything.

Finally, the author says the hardest part is not the technical work, but actually publishing something. Many people get stuck planning or setting up tools and never write real content. The key is to make and ship something simple, and then keep going.

In the comments, some people agree strongly with the author, saying this is how they learned web development years ago and that the basics still work well. Others point out that, while this method is good for learning or personal sites, it might not scale for bigger projects or teams. Some commenters share that working with plain HTML and FTP is refreshing, and helps them focus on content. A few say they wish more modern websites were this simple, as many sites today are slow and overloaded with unnecessary tools.

There are also comments about the value of RSS, with some readers happy to see it promoted, and others noting that many people do not use RSS anymore. Some mention that hand-writing XML can be tedious, but doing it once helps you understand how things work. A few commenters suggest that, even if you later move to a CMS or automation, starting simple is a good way to learn and avoid over-engineering.

Some people raise concerns about security, backups, and maintaining sites as they grow, saying that simple sites can become hard to manage over time without better systems. Others say that for a small personal blog, this approach is perfect and fun. Many agree with the main message: just start, keep it simple, and focus on publishing real content.

---

## Ask HN: Vxlan over WireGuard or WireGuard over Vxlan?

- 原文链接: [Ask HN: Vxlan over WireGuard or WireGuard over Vxlan?](item?id=46606854)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=46606854)

This post is about connecting computer networks using VXLAN and WireGuard, and which one should go "over" the other. VXLAN is a way to create a virtual network on top of existing networks, while WireGuard is a tool to make secure, encrypted connections.

The question is: should you put VXLAN inside WireGuard, or should you put WireGuard inside VXLAN? If you put VXLAN over WireGuard, you first make a secure tunnel with WireGuard, then run VXLAN to make your virtual network. If you do it the other way, you first make a virtual network with VXLAN, and then add security using WireGuard.

The article explains that people usually put VXLAN over WireGuard. This is because WireGuard is good at making secure tunnels, and VXLAN can use those tunnels to send network traffic between different places. Doing it this way is simpler, and it’s easier to manage. You can control security with WireGuard, and use VXLAN to connect many machines as if they are on the same local network.

The other way—putting WireGuard inside VXLAN—is less common. If you do this, you make one big virtual network, and then try to make small secure links inside it. This can make things more complex, and you may lose some security benefits of WireGuard. Also, WireGuard does not need a virtual network to work well.

The article also says that running VXLAN over WireGuard makes it easier to deal with things like NAT and firewalls. WireGuard uses one UDP port, which is easy to open. VXLAN alone can have trouble with this.

In the comments, some people agree that VXLAN over WireGuard is the best choice. They say it is simple and works well for most cases. Others mention they use this setup for home labs and small businesses, and it’s easy to manage.

A few commenters share that WireGuard is fast and easy to set up, so it makes sense to use it as the base. Some people warn that VXLAN adds extra data to each packet, making it a bit slower, but for most users, this is not a big problem.

One person says that if you need to connect many sites together and want strong security, VXLAN over WireGuard is safer and more reliable. Someone else asks if there are any special cases where you might want to do the opposite, but most replies say it’s rare.

A commenter adds that running WireGuard over VXLAN could be useful in some very large or unusual networks, but not for most people. Another person points out you should watch out for MTU issues—this is when packets get too big and need to be broken up, which can hurt performance.

Overall, most people agree: use WireGuard for security, then put your VXLAN on top if you need a virtual network. This keeps things simple and safe.

---

## Choosing learning over autopilot

- 原文链接: [Choosing learning over autopilot](https://anniecherkaev.com/choosing-learning-over-autopilot)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=46605716)

This article talks about using AI coding tools and how they change the way we learn and build software. The author loves using AI to code, but also worries it can make them lazy and stop real learning.

AI tools help you build things faster and try out new ideas quickly. They make it easy to experiment and see what works, and you can get feedback from others fast. This can help you learn by doing and make better systems. But there is a risk: you might use AI to just get work done quickly, not really understand the code, and stop learning new things. The author is afraid of just drifting along, using AI on autopilot, and missing out on important learning by doing.

To avoid this, the author shares some rules for using AI well. They use AI to learn in steps, throw away AI code and start over if needed, decide carefully how to break down problems, make small and clear code changes, and always write final docs by hand. AI should help you understand, not replace your thinking.

The author also explains what AI tools make easier: like hooking things together or turning ideas into code. But important thinking tasks—like picking the right libraries, organizing code, and explaining why you did something—should still be done by you. AI now lets you focus more on understanding systems deeply and running more experiments.

The workflow is to start messy: plan the problem, build a quick AI prototype, throw it away, and start fresh. Then, design the solution carefully, get feedback, and only then use AI to build the final code in clean steps. The author says AI code is cheap and easy to throw out, so don’t be afraid to start over.

They also say it’s important to break down problems well and make small, reviewable changes. This makes code easier to maintain and understand. Writing your own docs and commit messages helps you think clearly and shows if you really understand the work.

In the comment section, many people agree that AI can make you skip deep learning if you aren't careful. Some say they have become more productive but worry about not really understanding what the AI writes. Others share that AI is great for speeding up boring tasks, but you still need to know the basics to catch AI mistakes. A few commenters believe AI will change how new developers learn—some think this might hurt learning, but others see it as a chance to learn faster by doing.

Some programmers mention that they now review AI code more closely, and often throw away AI drafts just like the author suggests. Others argue that for simple, repetitive code, trusting the AI is fine, but for complex systems you still need to think deeply. There’s also a debate about writing documentation: some find AI helps draft it, but most agree that humans need to review and improve it.

A few commenters point out that using AI well takes discipline—you need to know when to trust it and when to do things yourself. Some share stories of AI making small mistakes that were easy to miss if they didn’t check the details. Overall, most agree with the author: AI tools are powerful, but you learn best when you use them to help you think and not just to do things quickly.

---

## Show HN: Ayder – HTTP-native durable event log written in C (curl as client)

- 原文链接: [Show HN: Ayder – HTTP-native durable event log written in C (curl as client)](https://github.com/A1darbek/ayder)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=46604862)

Ayder is a new event log and message bus system written in C that uses HTTP for communication, so you can use simple tools like curl as a client. The project aims to give strong data durability and high performance while being easy to set up and use.

Ayder works as a single binary with no big dependencies—no JVM, ZooKeeper, or special client libraries. It supports features like append-only logs, consumer groups, and high-availability (HA) clustering using the Raft consensus algorithm. Ayder stores data in sealed files and can recover quickly after crashes; in a test with 8 million messages, it recovered in about 40–50 seconds. For comparison, Kafka can take hours to recover in similar scenarios. Ayder’s HTTP API makes it easy to produce and consume messages, manage topics, and handle offsets. It also has a built-in key-value store with features like compare-and-swap and time-to-live. Stream processing is included, letting you filter, group, and join message streams without extra services.

Performance benchmarks show Ayder can handle around 50,000 to 100,000 messages per second with low latency (often under 4ms at the 99th percentile). It works well on ARM64 hardware, like the Snapdragon X Elite, and on regular cloud VMs. The system is meant to be simple: you can run it in Docker or build it from source, and the setup for HA clustering is controlled with environment variables. HA clusters use Raft to keep data safe and in sync between nodes. You can set write concerns for durability and latency tradeoffs.

The API is clean and easy: you create topics, write messages, consume messages, and commit offsets—all over HTTP. Data retention and partition management are also done via HTTP commands. Ayder is not a drop-in Kafka replacement (not protocol compatible), and it does not promise exactly-once delivery by itself. But it gives strong durability and is much easier to run than most other systems.

In the Hacker News comments, many people like the simplicity and the use of HTTP and curl for accessing the system. Some users praise the strong recovery times and the lack of heavy dependencies. A few express excitement about testing it on ARM laptops and using it for small projects or edge devices. Other commenters compare Ayder to Kafka and Redis Streams, pointing out tradeoffs: Kafka is more mature and feature-rich, but much harder to operate; Redis Streams is easy, but lacks strong durability. Some users wonder about real-world scaling, security, and how Ayder handles large cluster sizes. There are questions about the choice of C as a language and the safety of C, but others say C helps keep memory use low. A few ask about missing features, like SQL-like queries or Kafka protocol support, and some suggest this could be a good base for personal projects or small teams who don’t want the overhead of running Kafka. Overall, most see Ayder as an interesting, lightweight alternative for event streaming and logging.

---

