Hello everyone, this is the 2025-08-11 episode of Hacker News Daily Podcast. Today, we have news and discussions about recursion and loops, a new project for sharding Postgres, OpenSSH’s move to post-quantum cryptography, the loss of institutional memory, a simple daily habit for learning, the Byte Buddy Java library, and mixing Markdown with Custom Elements. Let’s get started.

First, let’s talk about recursion and loops. An article explains how tail-recursive functions can work just like loops in programming. Normally, recursion is slower than loops because each function call uses more memory on the stack. For example, when you sum a list with normal recursion, the program keeps part of the answer in memory for each step, so a long list uses a lot of stack space. Loops solve this by using an accumulator variable, which only needs a small, fixed amount of memory.

Tail recursion is a kind of recursion where the recursive call is the last thing the function does. If the compiler supports tail-call optimization, it can turn this into a loop, using no extra stack space. The article gives examples, such as summing a list with tail recursion by passing an accumulator along. It also shows that some problems, like counting even and odd numbers at the same time, or flattening a tree, are harder to write as tail-recursive functions.

There is also a method called continuation-passing style, or CPS, which can turn any function into a series of tail calls. Some functional language compilers use this to avoid stack overflows.

In the comments, some people prefer loops for being easy to read, while others like recursion for matching the way they think about problems, especially with trees. Some warn that not all languages support tail-call optimization, so tail-recursive functions can still use a lot of stack space. People give examples where recursion feels natural, but agree that for simple tasks like summing a list, loops or tail recursion are better for performance. A few mention that learning how to turn recursion into tail recursion helps you understand how programs use memory. There are also comments about CPS being powerful but hard to read, and that languages like Scheme and Racket handle tail recursion well. Others warn that in Python, deep recursion can crash your program. Some discuss real-world cases of CPS in compilers. The topic leads to a broad discussion about performance, language features, and how compilers work under the hood.

Next, PlanetScale has announced a new project called Neki. This is a sharded version of Postgres, built by the team that made Vitess. The goal is to let Postgres handle much bigger workloads by splitting data across many servers. Vitess already makes sharding easier for MySQL, and now PlanetScale wants to bring similar power to Postgres. Neki is not just a copy of Vitess; it is being built from scratch with new ideas, and will be open source. The team says more details will come later.

In the comments, many people are excited and hope Neki will be as useful for Postgres as Vitess is for MySQL. Some are curious about technical details, like how Neki will handle transactions and failover. Others ask why not just use Vitess with Postgres, and the team explains that Vitess depends on MySQL features, so new engineering is needed for Postgres. Some users hope Neki will make sharding simpler, while others have questions about open source plans, licensing, and user control. A few mention other sharding tools for Postgres and wonder how Neki will compare. There are also concerns about added complexity, and people hope for good documentation and support. Overall, the community is interested, but wants to see more details and real code.

Now, let’s look at OpenSSH and quantum security. OpenSSH now uses new cryptography methods to protect against future quantum computer attacks. If quantum computers become real and strong, they could break old encryption and read secret messages. OpenSSH started using post-quantum key agreement in version 9.0 and made mlkem768x25519-sha256 the default in version 10.0. If you connect with an older, less secure algorithm, you get a warning in version 10.1. You can turn off the warning, but the project recommends using the new algorithms.

Quantum computers could break the encryption that keeps SSH connections private. Even though strong quantum computers do not exist yet, attackers could save your encrypted data now and decrypt it later. This is called a “store now, decrypt later” attack. To stay safe, OpenSSH supports these new methods. If you get a warning, your server is not safe against quantum attacks, so you should update or change settings.

For digital signatures, quantum computers also pose a risk. But for signatures, attackers cannot use old data later, so there is less risk for past messages. OpenSSH plans to add new signature algorithms in the future.

Some people say quantum computers may never become strong enough, but the article says it is better to be safe. The team uses hybrid algorithms that mix old and new, so even if the new ones are broken, the connection is still as safe as before.

In the comments, many support the changes and say it is smart to prepare early. Some worry the new algorithms are not tested enough and could have flaws. Others feel quantum computers are still far away, so there is no rush. People talk about the risks of “store now, decrypt later” attacks for important data. There are technical questions about server updates and how to check if you are using safe algorithms. Some are annoyed by extra warnings and want easy ways to turn them off. There is discussion about hybrid algorithms, with most people agreeing it is a good idea to use both old and new for now. Some are excited to see OpenSSH moving fast, while others want more research. Many agree that even if quantum computers never work, stronger cryptography is still good.

Next, we have an article about institutional memory—the important information that organizations often forget. The article starts with a story from 1978, where a canal crew pulled a two-century-old plug from a canal, causing all the water to drain out. Old records had been destroyed in World War II, so nobody remembered the plug was there. The article gives more examples: Volkswagen repeated the same emissions cheating scandal in 1973 and 2015, and NASA had two shuttle accidents for similar reasons—ignoring warnings from engineers. Lockheed forgot how to build its TriStar airplane efficiently because it made so few planes. The article says that losing institutional memory can happen when people leave, paper records are lost, or digital files become unreadable. Sometimes, records are destroyed on purpose, as in the UK Windrush scandal, or lost quickly, like 100,000 US government webpages after a leadership change.

In the comments, many agree that institutional memory is important and share their own stories. Some say companies rely too much on a few experienced people, and when they leave, things fall apart. Others say that writing things down helps, but only if people know where to find the documents. Some warn that companies may forget things on purpose to avoid blame. Others note that technology changes fast, making old knowledge less useful. Some say keeping too much information can be a problem, because it gets hard to search. Suggestions include regular training and review sessions, and building a culture that values learning from mistakes. Some say even good documentation is useless if new workers do not know it exists. Lastly, some people wonder if forgetting can be good, letting organizations move on from outdated ideas.

Let’s move on to a daily habit article. The writer shares a four-step practice: Learn, Reflect, Apply, and Prepare. First, they learn something new each day, not just collecting facts but staying curious. Then, they reflect, often by writing in a notebook, to understand and see patterns. Next, they apply what they learned, even in small ways, because learning only matters if you use it. Finally, they prepare for the future, such as setting up a system or backing up files. Preparation is simple but gives big rewards later. The writer says these steps are not perfect, but returning to them helps keep learning fresh, lowers stress, and makes action easier.

In the comments, some readers agree that simple habits work better than complex tools. Others struggle with daily routines and ask for tips. Some wonder if writing by hand is better than typing, while others share ways to reflect, like talking to a friend or walking. One warns that too much preparation can become procrastination. Another says not every day will feel productive, and that’s okay. Some say these habits help with mental health. A few suggest adding a fifth step, like “rest,” to avoid burnout. Others ask for coding examples of applying new ideas. Many like the gentle approach and want to try it themselves.

Now, let’s talk about Byte Buddy, a Java library for runtime code generation. Byte Buddy lets you create and change Java classes while your program is running. Unlike basic Java tools that only allow proxies for interfaces, Byte Buddy can change any class with an easy-to-use API. You do not need to know Java bytecode or class file details to use it, but experts can define custom bytecode if needed. Classes made with Byte Buddy work even if Byte Buddy is not present later. It works with all Java versions and only depends on the ASM library.

Runtime code generation is important for libraries that need to work with unknown code, like Spring and Hibernate. Byte Buddy helps make dynamic programming easier and more powerful. It is well-known, has won awards, and is used in tools like Mockito, Hibernate, and Google’s Bazel. It gets over 75 million downloads each year.

To use Byte Buddy, you create an instance of the ByteBuddy class and can make new classes or change existing ones, such as overriding the toString method. You can also use it for Java agents that change any running Java program. Byte Buddy is open source and free, with lots of documentation and help online.

In the comments, many users praise Byte Buddy for making complex Java tricks easier. It hides the hard parts of bytecode and class loading. Others say Byte Buddy is important for mocking in tests and making frameworks flexible. Some share stories of solving real problems by adding features to classes they do not control. A few worry that runtime code generation can make debugging harder, so they suggest using it carefully. Some compare Byte Buddy with other tools, saying Byte Buddy is simpler and more modern. There are questions about class loaders and Java version compatibility. Some mention the challenge of keeping dependencies up to date, but most agree Byte Buddy does well. The creator is active and helpful. Overall, Byte Buddy is respected and useful in the Java world.

Finally, we have an article about mixing Markdown, HTML, and Custom Elements, or Web Components, to make web writing easier and more powerful. The author uses Markdown for most of his website, turning it into HTML on the server. Markdown is simple, but sometimes you need more, like a feedback form or subscription widget. Markdown allows raw HTML, so you can add your own tags. Custom Elements let you define your own HTML tags that expand into complex features in the browser. For example, a simple tag like <subscribe-to> can become a full form. You can also add settings or content between the tags.

The article gives examples of using this approach, shows how to design mini-languages for content, and talks about problems like Markdown not handling self-closing custom tags well. The author wrote a small program to fix tag formats before processing. He warns that making your own mini-languages can get too complex, but says it is powerful if done right. The article discusses doing the processing on the server or in the browser, and the trade-offs.

In the comments, some users are excited about combining Markdown and Custom Elements, saying it makes writing more flexible. Others warn that too many custom tags or mini-languages can become hard to maintain. Some point out that not all Markdown processors handle inline HTML the same way, so you need to test carefully. Some prefer to keep Markdown simple and avoid custom HTML. There is debate about server-side versus client-side processing. One commenter mentions worries about browser support, but most agree support is good now. Some share tips for avoiding errors with self-closing tags. Others like the language-design ideas, thinking about what you can automate for editors. There are also security questions about letting users write raw HTML or Custom Elements. Overall, readers find the article creative and full of good ideas.

That’s all for today’s episode. Thank you for listening to the Hacker News Daily Podcast. We hope you found these stories interesting and useful. See you next time.