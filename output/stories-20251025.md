# Hacker News 故事摘要 - 2025-10-25

## 今日概述

Today’s top Hacker News stories cover new battery storage helping California’s power grid, how Linux runs programs, and tools for making diagrams and UI themes. There are articles about safer C/C++ programs with ARM’s Memory Tagging, AI agent training from Microsoft, and simple ways to test Bluetooth beacons. Other stories include the loss of a small animal species and a guide to rock tumbling. The main themes are clean energy, new software tools, hardware safety, and learning more about how things work.

---

## California invests in battery energy storage, leaving rolling blackouts behind

- 原文链接: [California invests in battery energy storage, leaving rolling blackouts behind](https://www.latimes.com/environment/story/2025-10-17/california-made-it-through-another-summer-without-a-flex-alert)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=45706527)

California used to have power problems every summer, with rolling blackouts and warnings to use less electricity. Now, the state has stopped these emergencies, thanks to big investments in battery energy storage.

Batteries store extra solar power during the day and send it to the grid when people need it most, like in the late afternoon. California built a lot of battery capacity very quickly—going from just 500 megawatts in 2020 to more than 15,700 megawatts now. Experts say this change has made the electric grid much stronger and more reliable, even during heat waves and wildfires. Batteries help California move away from old gas power plants, which don’t work well in hot weather, and use more renewable energy.

Lithium-ion batteries, the most common kind, can run for four to six hours—enough for peak times, but sometimes the grid still needs help from natural gas. Other battery types, like iron-air and flow batteries, could last longer but are still new and expensive. Even so, the price of batteries is dropping fast, and new batteries are starting to cost as little as new gas plants.

While some U.S. leaders want to support fossil fuels, both California and Texas are building more batteries. Most batteries are made in China, but new U.S. tariffs and policies are helping American battery makers grow. Some companies now use only U.S.-sourced materials, which also brings tax benefits.

There are still problems to solve. California’s power grid is old and needs more upgrades. Building new energy projects can take a long time because of strict rules, though the state is speeding up some permits. Safety is also a big issue: a fire at a large battery facility caused health concerns from dangerous chemicals. Experts say it’s important to use different kinds of batteries to lower risks.

California is almost done with coal power, and renewables now make up about 60% of its electricity. In 2024, the grid ran on 100% clean energy for several hours each day. Leaders say the new energy system works—the state has stayed reliable without the old blackouts.

Commenters on Hacker News mostly praised California’s progress, saying battery storage is a real turning point. Some shared technical details about different battery types and how they work. A few people were surprised by the speed of battery growth and asked if other states could follow. Others worried about the safety of large battery sites, pointing to the Moss Landing fire. Some commenters felt the permitting process for new projects is still too slow, while others wondered if the grid upgrades will keep up with demand.

A few users said it’s smart to combine batteries with demand response, where companies and homes use less power at busy times. Others debated the role of natural gas—some think it’s still needed for now, while some hope batteries will replace it soon. There were questions about battery recycling and how to handle old batteries safely. Some people liked the idea of more domestic battery production, but a few worried that tariffs could make batteries more expensive.

Overall, most commenters agreed that battery storage is helping California’s grid, but they want to see more improvements in cost, safety, and long-term solutions.

---

## The Journey Before main()

- 原文链接: [The Journey Before main()](https://amit.prasad.me/blog/before-main)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=45706380)

This article explains what happens before your program’s main() function starts running on Linux. It starts with the execve system call, which is how the kernel loads and starts a new program.

The execve call needs the program’s file name, arguments, and environment variables. Many programming languages have higher-level functions that eventually use execve to start new processes. If a script begins with a shebang line (like #!/usr/bin/python3), the kernel uses that interpreter.

Executable files on Linux use the ELF format. The ELF header tells the kernel important things, like where to find the code, what kind of CPU the program runs on, and where to start running code (the entry point). The ELF file has sections for code, data, variables, and tables for linking to shared libraries like libc. Even a simple “Hello, World!” program can have thousands of symbols because of all the extra code needed for linking and runtime support.

When the kernel loads a program, it reads each ELF section and puts them in memory. It also sets up security features, like randomizing memory addresses and marking memory as non-executable. The kernel must also set up the stack. The stack holds variables, function call information, arguments, and environment variables. The kernel also adds an auxiliary vector, which gives the program more information about the system, such as page size.

The entry point in the ELF file is usually a function called _start. This is the first code that runs in your program. Most languages have some startup code here before calling main(). For example, Rust and C set up the runtime and then call your main function. Languages like Java or Python do even more during this step.

The article shows some simple code examples and explains how the memory layout and stack are prepared. In the end, after all the setup, your main() function is finally called.

Commenters on Hacker News liked the clear explanation and appreciated the “rabbit hole” look at process startup. Some pointed out extra details, like how security features (like ASLR) make memory addresses less predictable, and how the kernel sets up more than just the stack, like file descriptors and process tables. Others shared stories about debugging problems that happen before main(), and how useful tools like strace or gdb can be for seeing what happens early in program startup. Some people discussed how the process is different on other operating systems, like macOS or Windows, and a few linked to similar resources or books for deeper reading. A few comments noted that understanding this process helps when working with embedded systems or writing custom runtimes. Some wished for more detail about kernel-level work, while others liked that the article stayed high-level and easy to follow. Overall, readers enjoyed seeing how much goes on before a program truly begins.

---

## Show HN: Diagram as code tool with draggable customizations

- 原文链接: [Show HN: Diagram as code tool with draggable customizations](https://github.com/RohanAdwankar/oxdraw)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=45706792)

This project is about a tool called Oxdraw that helps you make diagrams using code and also lets you drag and change things by hand. It is written in Rust, uses Mermaid syntax, and has a web editor built with React.

Oxdraw lets you write diagrams as code, so you can keep them in version control and work with them like any other text file. You can use the command line to turn your Mermaid (.mmd) files into images (SVG or PNG), or you can launch an interactive editor to move things around and change styles. When you change something with the editor, Oxdraw saves those changes back into the Mermaid file as comments, so your diagram is still compatible with other Mermaid tools. You can color nodes, change edge styles, add control points to lines, and group nodes to move them together. There are many keyboard shortcuts and features to help you work faster, like grid snapping and live guides. The tool tries to balance between clear lines and smooth paths, but the author says there is still work to do on the path algorithm.

Oxdraw was made because the author used Mermaid a lot, but found it hard to make small changes to diagrams. He often had to move his work to tools like Lucidchart to finish the diagram. Oxdraw tries to give you the best of both: the power of code and the easy editing of a GUI. You can install it with Cargo, and the code is open under the MIT license.

In the comments, some people are excited because they often need both code and easy editing for diagrams. They like the idea of mixing Mermaid with a visual editor. Some users ask how Oxdraw compares to other tools, like Excalidraw or Diagrams.net, and if it supports more complex features. A few people say they have wanted something like this for a while, and they hope it can export to common formats. There is interest in how well the path algorithm works, especially when diagrams get big. Some users are glad it is open source and written in Rust, while others wonder if it will be easy to install and use on different systems. A few suggest features like better AI integration or more export options. Some point out that syncing visual changes back to code is hard, but are impressed that Oxdraw tries to do this. Overall, there is a lot of support and some helpful feedback about where Oxdraw could go next.

---

## How programs get run: ELF binaries

- 原文链接: [How programs get run: ELF binaries](https://lwn.net/Articles/631631/)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=45706938)

This article explains how Linux runs programs using ELF (Executable and Linkable Format) binaries. ELF is the main way Linux stores and loads programs.

When you start a program, the Linux kernel checks that the file is an ELF file. The ELF file has a header and a table that tells the kernel how to load the program into memory. The kernel cares about a few parts: where to load code and data, if the program needs a special runtime linker, and if the stack should be executable.

The kernel reads these parts, prepares the new program, and clears out the old program. It stops other threads, resets signals, and closes files that should not be kept open. The kernel then sets up new memory for the program, including a random stack location to improve security. It copies the program’s code and data into memory, sets up empty space for variables, and adds special pages if needed.

Next, the kernel sets up the program’s stack. It adds the command-line arguments, environment variables, and an “auxiliary vector”—a list of key values the program might need, like its entry point or some random bytes for security. The stack is carefully arranged so the program can find all its data easily, even if the exact memory addresses are random.

If the program is dynamically linked (most are), the kernel also loads a runtime linker (often /lib64/ld-linux-x86-64.so.2). This linker loads any shared libraries the program needs and then starts the program.

Linux can also run 32-bit ELF programs on a 64-bit system. The kernel has special code to handle this, using compatibility layers that adjust how memory and registers are set up.

The Hacker News comments give extra context. Some readers like how clear the article is, saying it helps them understand what happens when they run a program. Others are surprised at how complex the process is, and mention that many developers do not know about these details. A few people point out how ELF makes it possible to run programs from other systems, like running 32-bit apps on 64-bit Linux.

Some comments discuss security, like how the stack is randomized and not executable by default. There’s praise for how the kernel only needs to know a little about ELF, leaving most of the hard work to the runtime linker. A few users mention debugging tools like objdump, which help them look inside ELF files.

Others share stories about problems caused by missing or broken shared libraries, and how understanding ELF helped them fix these issues. Some are interested in how other operating systems handle program loading, and compare ELF to formats like PE on Windows or Mach-O on macOS. There’s also talk about how the execve system call is a key part of Linux, but is often overlooked.

Finally, some users ask questions about specific parts of the process, like how environment variables are passed or how the kernel handles very old programs. Overall, readers agree this is a complex but important topic for anyone working with Linux.

---

## Show HN: Shadcn/UI theme editor – Design and share Shadcn themes

- 原文链接: [Show HN: Shadcn/UI theme editor – Design and share Shadcn themes](https://shadcnthemer.com)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=45706487)

This post is about a new web tool called ShadCN Themer. The tool helps people make, change, and share themes for the shadcn/ui component library.

The main idea is to let users design custom color themes easily. You can start with a preset theme or import your own. The site shows many ready-made themes like “Velvet (Dark),” “Violet Bloom,” and “Vintage Paper.” Each theme has its own color palette and style. You can filter themes by color, for example, red, blue, or green. The site is simple to use, with clear buttons for signing in, signing up, and importing new themes. When you pick a theme, you can see who made it—most are by the user “mike.” After you make or change a theme, you can save and share it with others. There is a connection to GitHub for people who want to see the code or share their work. The tool is helpful for developers who use shadcn/ui and want their apps to look special. The website lets you test and preview themes before using them. Everything is online, so you do not need to install anything. The site also covers privacy, terms of use, and has a contact link.

In the comments, some users are very happy to see a theme editor for shadcn/ui, saying it fills a real need. Others ask if it can export themes in different formats, like JSON or CSS, to use in other tools. A few people wish there were more themes from different users, not just the creator. One developer suggests adding a way to preview themes on real UI components, not just color blocks. Some users talk about using this tool in their work or with their teams. Another person wonders if the site will let people sell or trade themes in the future. There is some talk about the importance of good design for apps, and how tools like this can help people who are not designers. A few users give feedback about the user interface, saying it is simple and easy to use. Someone asks about the project’s open source plans. Another user likes that there is no need to make an account to browse themes. Some people share ideas for new features, like dark mode previews or support for more color spaces. A few users thank the creator for sharing and hope the tool keeps growing.

---

## ARM Memory Tagging: how it improves C/C++ memory safety (2018) [pdf]

- 原文链接: [ARM Memory Tagging: how it improves C/C++ memory safety (2018) [pdf]](https://llvm.org/devmtg/2018-10/slides/Serebryany-Stepanov-Tsyrklevich-Memory-Tagging-Slides-LLVM-2018.pdf)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=45706815)

This article talks about ARM’s Memory Tagging Extension (MTE) and how it can make C and C++ programs safer. C and C++ have many memory safety problems, like use-after-free and buffer overflows, which cause crashes and security bugs.

MTE is a new hardware feature for ARM processors. It adds a small “tag” to every 16 bytes of memory and to every pointer. When a program loads or stores data, the hardware checks that the pointer and the memory have matching tags. If they do not match, it means there is a memory safety bug, and the program gets an error. This helps catch bugs like using memory after it is freed, or writing past the end of an array.

Using MTE has some cost. It needs more RAM (about 3–5% extra) and a bit more CPU time, but the authors hope this will be “low-single-digit” percentage. MTE only works on 64-bit systems. It adds new instructions to set and check tags. When memory is given to a program (for example, with malloc or new), it gets a random tag, and the pointer is also tagged. When memory is freed, it gets a new tag, so old pointers will no longer match.

There are other similar systems, like SPARC ADI and software tools like AddressSanitizer (ASAN), but MTE is faster and easier to use in real products because it is built into the hardware. The article explains some technical details, like how compilers should handle the tags and how optimizations can reduce the extra cost. It also talks about future ideas, like using MTE for race detection or better garbage collection.

In the comments, many people are excited about MTE and think it is a big step for software safety. Some point out that memory bugs cause many security problems, so this is very important. Others say that while MTE is good, it is not perfect—some bugs may not be caught, and it does not fix all C/C++ problems. A few users worry about the extra memory and CPU cost, especially for small devices. Some developers think that languages with built-in safety, like Rust, are still better in the long run. Others say that hardware solutions like MTE are useful because they help with old code and big projects that cannot move to new languages quickly. Some people ask when real ARM chips will have MTE, and a few share their own experiences with similar tools. Overall, the comments show both hope and realistic caution about how much MTE can help.

---

## Agent Lightning: Train agents with RL (no code changes needed)

- 原文链接: [Agent Lightning: Train agents with RL (no code changes needed)](https://github.com/microsoft/agent-lightning)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=45706729)

Agent Lightning is a new tool from Microsoft that helps you train AI agents with reinforcement learning, and you do not have to change your agent’s code. It works with many agent frameworks like LangChain, OpenAI Agent SDK, AutoGen, CrewAI, and even plain Python code. The idea is to make your agent better by learning from its actions, prompts, and results, all without big rewrites or lock-in to one tool.

You add a small helper or let the built-in “tracer” watch what your agent does. All the events—like prompts, tool calls, and rewards—are recorded. These events are saved in a central store called LightningStore. Then, a learning algorithm reads this data and tries to improve your agent’s behavior. For example, it can rewrite prompts or update policy weights. The “Trainer” part sends data where it needs to go and keeps everything working together.

You can pick which agents to optimize if you have many working together. The tool supports more than just reinforcement learning; it also works with prompt optimization and supervised fine-tuning. Installing it is simple with pip, and you can follow guides to get started or see real examples.

People have used Agent Lightning for things like training agents to write and fix SQL, or building games with smart AI. The code is open source under the MIT license, and the team invites people to help improve it.

In the Hacker News comments, some users are excited about training agents without code changes. They say this makes it easier to try new ideas or add learning to existing projects. Others ask about how well it works with different agent frameworks or if it slows things down. A few people worry about how safe it is to let an agent change itself, and wonder how to control what changes are made.

Some users compare Agent Lightning to other tools, and note that being able to use it with any agent is a big plus. There are questions about how rewards are given to the agent, and if it is easy to set up reward signals for real-world tasks. A few developers wish for more detailed examples, or simple tutorials for beginners.

One comment points out that recording and storing every prompt and action could use a lot of storage for long training runs. Another person likes that it works with open source tools, not just Microsoft’s own products. Finally, some users hope that this project will help improve agent performance in real-world jobs, not just in demos or research.

---

## In memory of the Christmas Island shrew

- 原文链接: [In memory of the Christmas Island shrew](https://news.mongabay.com/2025/10/in-memory-of-the-christmas-island-shrew/)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=45706624)

The article talks about the extinction of the Christmas Island shrew, a small mammal once living on Christmas Island in the Indian Ocean. The shrew, which weighed only about five or six grams, was once common on the island but is now officially gone.

The shrew was different from other Australian animals because it was not a marsupial. Scientists think it arrived on the island a long time ago from Indonesia, traveling on floating plants. In the late 1800s, people studying the island saw many shrews, but their numbers quickly dropped. The main reason was the arrival of black rats, which came on ships and brought a deadly parasite. The rats and the disease they carried killed off the native mammals, including the shrew.

For many years, people thought the shrew was extinct. Then, in 1958, a few were seen during forest clearing, and again in 1984, when a female was found and kept alive for some time. A male was found later, but he died quickly, and the female died not long after. No more shrews have been found since then, even after many searches. Scientists checked the stomachs of feral cats on the island but found no signs of shrews. Now, official records say the shrew is extinct.

The article says this loss is part of a sad record for Australia, which has lost more mammals than any other country since colonization. The story of the shrew shows how quickly an animal can disappear when new species are introduced and when people change the environment. The shrew’s life was quiet and simple, needing only a small space and some insects to eat. Now, the silent forest is a reminder of what is lost.

In the comment section, some people say the extinction is very sad and that even small animals matter. Others point out that this is not just about one shrew, but about many animals lost from islands around the world after humans arrived. Some commenters feel angry about how humans bring invasive species without thinking about the damage. Others discuss how hard it is to notice or save very small, secretive creatures before it’s too late. A few people wonder if the shrew might still be out there, hiding, since some animals thought extinct have been found again years later. Some call for stronger rules to stop new animals and diseases from being brought to islands. There are also voices saying that remembering these lost animals can help us care more for the ones still living. Finally, a few commenters share hope that stories like this can lead to better protection of nature in the future.

---

## Testing out BLE beacons with BeaconDB

- 原文链接: [Testing out BLE beacons with BeaconDB](https://blog.matthewbrunelle.com/testing-out-ble-beacons-with-beacondb/)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=45706705)

This article talks about testing Bluetooth Low Energy (BLE) beacons using a tool called BeaconDB. The writer wanted to see how well BLE beacons work and how easy it is to collect their signals.

They explain that BLE beacons are small devices that send out signals. Phones and computers can pick up these signals and use them to know where they are, like inside a building. The author used a few cheap BLE beacons and set them up around a room. BeaconDB is a tool that helps you track and record all the signals from these beacons. The tool saves the information in a database, so you can look at it later.

The setup was simple. The author turned on the beacons, started BeaconDB on their laptop, and walked around the room. The tool showed how strong the signal was from each beacon. This helped the author see which beacons were close and which were far away. They noticed that walls and furniture made the signal weaker. The database made it easy to see all the data at once and find patterns.

The writer says BLE beacons are useful for tracking things indoors. For example, stores can use them to know where people are shopping. Museums can use them to give visitors more information about displays. The author liked that BeaconDB is open source and easy to use, even for people who are not experts.

In the comments, some people said BLE beacons are great for many projects, like finding lost keys or tracking equipment. Others warned that BLE signals can be blocked by metal or thick walls, so they do not always work perfectly. A few readers asked if using many beacons in one place could cause problems with interference. Some shared their own tools for working with BLE beacons and compared them to BeaconDB.

One commenter liked that BeaconDB is open source and said it is good for learning. Another person worried about privacy, saying stores or apps could use beacons to track people without them knowing. Someone else pointed out that BLE beacons use very little battery, which is helpful for long-term use. In general, readers thought the article showed a simple way to get started with BLE beacons, but said there are still some challenges to solve.

---

## Rock Tumbler Instructions

- 原文链接: [Rock Tumbler Instructions](https://rocktumbler.com/tips/rock-tumbler-instructions/)
- HN链接: [Hacker News讨论](https://news.ycombinator.com/item?id=45705125)

This article explains how to use a rock tumbler to turn rough rocks into shiny, polished stones. It gives step-by-step instructions and shares tips to get the best results.

First, it says rock tumbling is easy if you follow some simple rules. Rocks that work best are hard (between 6 and 7 on the Mohs scale), not too soft, and not too big or small. Good rocks for tumbling include types of chalcedony, quartz, and some other stones like granite and basalt.

The three main “Golden Rules” are: use good rocks (“garbage in means garbage out”), avoid mixing up different grits or types of rocks (to stop scratches), and be patient because great results take time. You should always check your rocks before starting. Throw away any that are cracked, too soft, or have holes, since they can ruin the whole batch.

It’s best to put rocks of similar size and hardness together, and to fill the tumbler about two-thirds full. If you don’t have enough rocks, you can use small ceramic pieces as filler. This helps the rocks tumble smoothly and stops them from getting damaged.

The process happens in four steps:  
1. Coarse grind – use rough grit and tumble for a week.  
2. Medium grind – use finer grit, clean everything well, and tumble another week.  
3. Fine grind/pre-polish – use even finer grit and tumble for another week.  
4. Polish – use a special powder, clean everything again, and tumble for a final week.

After each step, you must wash the rocks and the equipment very well so grit doesn’t go into the next stage. Never pour the dirty water down the drain because it can block pipes. At the end, if the stones don’t shine, you can “burnish” them by tumbling with soap and water for a short time.

The article also suggests keeping a record of what you do, so you can remember what works best. There’s even a printable log to help you track your progress.

In the comments, many people say rock tumbling is a fun and satisfying hobby, especially for kids and families. Some share tips about using different types of grit or adding ceramic media for better results. A few warn that it can take a long time (weeks for each batch) and that patience is very important. Others talk about noise from the tumblers and suggest putting them in the garage or basement.

Some readers mention that using poor-quality rocks almost never leads to good results, even if you follow all the steps perfectly. Others note that careful cleaning between steps is the most important part—one mistake can ruin the polish. There are also tips about recycling water and being careful not to harm plumbing.

A couple of commenters tried shortcuts, like skipping steps or mixing different rocks, and found it didn’t work well. Overall, most agree that following the instructions closely gives the best results, and the final polished stones are worth the effort.

---

